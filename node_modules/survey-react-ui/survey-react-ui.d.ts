/*Type definitions for Survey JavaScript library v1.9.1
Copyright (c) 2015-2021 Devsoft Baltic OÜ  - http://surveyjs.io/
Definitions by: Devsoft Baltic OÜ <https://github.com/surveyjs/>
*/
// Dependencies for this module:
//   ../../../../survey-core
//   ../../../../react

import { Base, Question, PageModel, SurveyError } from "survey-core";
import { SurveyModel, QuestionMatrixDropdownRenderedCell, SurveyWindowModel, SurveyElement, QuestionRowModel, ItemValue, QuestionSelectBase } from "survey-core";
import { SurveyModel } from "survey-core";
import { PageModel } from "survey-core";
import { PanelModelBase } from "survey-core";
import { IElement, Base } from "survey-core";
import { PanelModel } from "survey-core";
import { FlowPanelModel, Question } from "survey-core";
import { Base, SurveyElement, SurveyError, Question, QuestionMatrixDropdownRenderedCell } from "survey-core";
import { LocalizableString } from "survey-core";
import { Question } from "survey-core";
import { Base } from "survey-core";
import { QuestionCommentModel } from "survey-core";
import { QuestionRankingModel } from "survey-core";
import { QuestionDropdownModel } from "survey-core";
import { QuestionMatrixModel } from "survey-core";
import { QuestionHtmlModel } from "survey-core";
import { QuestionFileModel } from "survey-core";
import { QuestionMultipleTextModel } from "survey-core";
import { MultipleTextItemModel } from "survey-core";
import { QuestionRadiogroupModel } from "survey-core";
import { ItemValue } from "survey-core";
import { QuestionTextModel } from "survey-core";
import { QuestionBooleanModel, Base } from "survey-core";
import { QuestionEmptyModel } from "survey-core";
import { QuestionMatrixDropdownModelBase, QuestionMatrixDropdownRenderedRow, QuestionMatrixDropdownRenderedCell, Question } from "survey-core";
import { QuestionMatrixDynamicModel } from "survey-core";
import { SurveyModel, QuestionPanelDynamicModel } from "survey-core";
import { QuestionRatingModel } from "survey-core";
import { QuestionExpressionModel } from "survey-core";
import { QuestionImagePickerModel } from "survey-core";
import { QuestionImageModel } from "survey-core";
import { QuestionSignaturePadModel } from "survey-core";
import { QuestionButtonGroupModel, ButtonGroupItemValue, ButtonGroupItemModel } from "survey-core";
import { Base, QuestionCustomModel, QuestionCompositeModel } from "survey-core";
import { PopupModel, PopupBaseViewModel } from "survey-core";
import { ListModel } from "survey-core";
import { SurveyElement } from "survey-core";
import { Base, Action, ActionContainer } from "survey-core";
import { Action } from "survey-core";
import { QuestionMatrixDropdownRenderedRow } from "survey-core";
import { QuestionRowModel, PanelModelBase } from "survey-core";
import { Base, Action } from "survey-core";

export { ReactSurveyModel as Model };
export { ReactWindowModel as WindowModel };

export declare class Survey extends SurveyElementBase<any, any> implements ISurveyCreator {
    static get cssType(): string;
    static set cssType(value: string);
    protected survey: ReactSurveyModel;
    constructor(props: any);
    protected getStateElement(): Base;
    shouldComponentUpdate(nextProps: any, nextState: any): boolean;
    componentDidUpdate(prevProps: any, prevState: any): void;
    componentDidMount(): void;
    componentWillUnmount(): void;
    doRender(): JSX.Element;
    protected renderElement(): JSX.Element;
    get css(): any;
    set css(value: any);
    handleTryAgainClick(event: any): void;
    protected renderCompleted(): JSX.Element;
    protected renderCompletedBefore(): JSX.Element;
    protected renderLoading(): JSX.Element;
    protected renderStartPage(): JSX.Element;
    protected renderSurvey(): JSX.Element;
    protected renderTimerPanel(location: string): JSX.Element;
    protected renderPage(page: PageModel): JSX.Element;
    protected renderProgress(isTop: boolean): JSX.Element;
    protected renderNavigation(navPosition: string): JSX.Element;
    protected renderEmptySurvey(): JSX.Element;
    protected createSurvey(newProps: any): void;
    protected updateSurvey(newProps: any, oldProps?: any): void;
    protected setSurveyEvents(): void;
    createQuestionElement(question: Question): JSX.Element;
    renderError(key: string, error: SurveyError, cssClasses: any): JSX.Element;
    questionTitleLocation(): string;
    questionErrorLocation(): string;
}
export declare function attachKey2click(element: JSX.Element, viewModel?: any, options?: {
    processEsc: boolean;
}): JSX.Element;

export declare class ReactSurveyModel extends SurveyModel {
    renderCallback: () => void;
    constructor(jsonObj?: any);
    render(): void;
    mergeCss(src: any, dest: any): void;
    doAfterRenderSurvey(el: any): void;
    protected onLoadSurveyFromService(): void;
    protected onLoadingSurveyFromService(): void;
    setCompletedState(value: string, text: string): void;
    start(): boolean;
    wrapRow(element: JSX.Element, row: QuestionRowModel): JSX.Element;
    wrapElement(element: JSX.Element, question: SurveyElement): JSX.Element;
    wrapItemValue(element: JSX.Element, question: QuestionSelectBase, item: ItemValue): JSX.Element;
    wrapMatrixCell(element: JSX.Element, cell: QuestionMatrixDropdownRenderedCell, reason?: string): JSX.Element;
}
export declare class ReactWindowModel extends SurveyWindowModel {
    constructor(jsonObj?: any, model?: ReactSurveyModel);
    protected createSurvey(jsonObj: any): SurveyModel;
    get renderCallback(): () => void;
    set renderCallback(val: () => void);
}

export declare class SurveyNavigationBase extends React.Component<any, any> {
    constructor(props: any);
    protected get survey(): SurveyModel;
    protected get css(): any;
    componentDidMount(): void;
    componentWillUnmount(): void;
}

export declare class SurveyTimerPanel extends React.Component<any, any> {
    constructor(props: any);
    protected get survey(): SurveyModel;
    update: () => void;
    componentDidMount(): void;
    componentWillUnmount(): void;
    render(): JSX.Element;
}

export declare class SurveyNavigation extends SurveyNavigationBase {
    constructor(props: any);
    handlePrevClick(event: any): void;
    handleNextClick(event: any): void;
    handleNextMouseDown(event: any): boolean;
    handleMouseDown(event: any): boolean;
    handleCompleteClick(event: any): void;
    handlePreviewClick(event: any): void;
    handleStartClick(event: any): void;
    render(): JSX.Element;
    protected renderButton(click: any, mouseDown: any, text: string, btnClassName: string): JSX.Element;
}

export declare class SurveyPage extends SurveyPanelBase {
    constructor(props: any);
    protected getPanelBase(): PanelModelBase;
    get page(): PageModel;
    protected renderElement(): JSX.Element;
    protected renderTitle(): JSX.Element;
    protected renderDescription(): JSX.Element;
}

export declare class SurveyRow extends SurveyElementBase<any, any> {
    constructor(props: any);
    protected getStateElement(): Base;
    protected get css(): any;
    protected canRender(): boolean;
    protected renderElementContent(): JSX.Element;
    protected renderElement(): JSX.Element;
    componentDidMount(): void;
    shouldComponentUpdate(nextProps: any, nextState: any): boolean;
    componentWillUnmount(): void;
    protected createElement(element: IElement, elementIndex?: number): JSX.Element;
}

export declare class SurveyPanel extends SurveyPanelBase {
    constructor(props: any);
    get panel(): PanelModel;
    protected renderElement(): JSX.Element;
    protected wrapElement(element: JSX.Element): JSX.Element;
    protected renderContent(style: any, rows: JSX.Element[], className: string): JSX.Element;
    protected renderTitle(): JSX.Element;
    protected renderDescription(): JSX.Element;
    protected renderBottom(): JSX.Element;
}

export declare class SurveyFlowPanel extends SurveyPanel {
    constructor(props: any);
    get flowPanel(): FlowPanelModel;
    componentDidMount(): void;
    componentWillUnmount(): void;
    protected getQuestion(name: string): Question;
    protected renderQuestion(question: Question): string;
    protected renderRows(): Array<JSX.Element>;
    protected renderHtml(): JSX.Element;
    protected renderNodes(domNodes: Array<Node>): Array<JSX.Element>;
    protected renderParentNode(node: Node): JSX.Element;
    protected renderNode(node: Node): JSX.Element;
    protected renderContent(style: any, rows: JSX.Element[]): JSX.Element;
}

export interface ISurveyCreator {
    createQuestionElement(question: Question): JSX.Element;
    renderError(key: string, error: SurveyError, cssClasses: any): JSX.Element;
    questionTitleLocation(): string;
    questionErrorLocation(): string;
}
export declare class SurveyQuestion extends SurveyElementBase<any, any> {
    static renderQuestionBody(creator: ISurveyCreator, question: Question): JSX.Element;
    constructor(props: any);
    protected getStateElement(): Base;
    protected get question(): Question;
    componentDidMount(): void;
    componentWillUnmount(): void;
    componentDidUpdate(prevProps: any, prevState: any): void;
    protected canRender(): boolean;
    protected renderElement(): JSX.Element;
    protected wrapElement(element: JSX.Element): JSX.Element;
    protected renderQuestion(): JSX.Element;
    protected renderDescription(cssClasses: any, isUnderInput?: boolean): JSX.Element;
    protected renderComment(cssClasses: any): JSX.Element;
    protected renderHeader(question: Question): JSX.Element;
    protected renderErrors(cssClasses: any, location: string): JSX.Element;
}
export declare class SurveyElementErrors extends ReactSurveyElement {
    constructor(props: any);
    protected get id(): string;
    protected get element(): SurveyElement;
    protected get location(): string;
    protected canRender(): boolean;
    componentDidUpdate(prevProps: any, prevState: any): void;
    componentWillUnmount(): void;
    protected renderElement(): JSX.Element;
}
export declare abstract class SurveyQuestionAndErrorsWrapped extends ReactSurveyElement {
    [index: string]: any;
    constructor(props: any);
    protected getStateElement(): Base;
    protected get question(): Question;
    protected get creator(): ISurveyCreator;
    protected getQuestion(): Question;
    protected get itemCss(): string;
    componentDidMount(): void;
    componentDidUpdate(prevProps: any, prevState: any): void;
    protected doAfterRender(): void;
    protected canRender(): boolean;
    protected renderErrors(errorsLocation: string): JSX.Element;
    protected renderContent(): JSX.Element;
    protected abstract renderElement(): JSX.Element;
    protected getShowErrors(): boolean;
    protected renderQuestion(): JSX.Element;
}
export declare class SurveyQuestionAndErrorsCell extends SurveyQuestionAndErrorsWrapped {
    [index: string]: any;
    protected cellRef: React.RefObject<HTMLTableCellElement>;
    constructor(props: any);
    componentWillUnmount(): void;
    protected renderElement(): JSX.Element;
    protected getCellStyle(): any;
    protected getHeaderText(): string;
    protected wrapCell(cell: QuestionMatrixDropdownRenderedCell, element: JSX.Element): JSX.Element;
}

export declare class SurveyElementBase<P, S> extends React.Component<P, S> {
    static renderLocString(locStr: LocalizableString, style?: any, key?: string): JSX.Element;
    constructor(props: any);
    componentDidMount(): void;
    componentWillUnmount(): void;
    componentDidUpdate(prevProps: any, prevState: any): void;
    render(): JSX.Element;
    protected wrapElement(element: JSX.Element): JSX.Element;
    protected get isRendering(): boolean;
    protected getRenderedElement(): Base;
    protected canRender(): boolean;
    protected renderElement(): JSX.Element;
    protected get changedStatePropName(): string;
    protected getStateElements(): Array<Base>;
    protected getStateElement(): Base;
    protected get isDisplayMode(): boolean;
    protected renderLocString(locStr: LocalizableString, style?: any): JSX.Element;
    protected canUsePropInState(key: string): boolean;
}
export declare class ReactSurveyElement extends SurveyElementBase<any, any> {
    constructor(props: any);
    protected get cssClasses(): any;
}
export declare class SurveyQuestionElementBase extends SurveyElementBase<any, any> {
    control: HTMLElement;
    constructor(props: any);
    componentDidUpdate(prevProps: any, prevState: any): void;
    componentDidMount(): void;
    componentWillUnmount(): void;
    protected updateDomElement(): void;
    protected get questionBase(): Question;
    protected getRenderedElement(): Base;
    protected get creator(): ISurveyCreator;
    protected canRender(): boolean;
    shouldComponentUpdate(): boolean;
    protected get isDisplayMode(): boolean;
    protected wrapCell(cell: any, element: JSX.Element, reason: string): JSX.Element;
}
export declare class SurveyQuestionUncontrolledElement<T extends Question> extends SurveyQuestionElementBase {
    constructor(props: any);
    protected get question(): T;
    updateValueOnEvent: (event: any) => void;
    protected setValueCore(newValue: any): void;
    protected getValueCore(): any;
    protected updateDomElement(): void;
}

export declare class SurveyQuestionComment extends SurveyQuestionUncontrolledElement<QuestionCommentModel> {
    constructor(props: any);
    protected renderElement(): JSX.Element;
}
export declare class SurveyQuestionCommentItem extends ReactSurveyElement {
    protected canRender(): boolean;
    protected renderElement(): JSX.Element;
}

export declare class SurveyQuestionCheckbox extends SurveyQuestionElementBase {
    constructor(props: any);
    protected get question(): QuestionCheckboxModel;
    protected renderElement(): JSX.Element;
    protected getColumns(cssClasses: any): JSX.Element[];
    protected getItems(cssClasses: any): Array<any>;
    protected get textStyle(): any;
    protected renderItem(key: string, item: any, isFirst: boolean, cssClasses: any, index: string): JSX.Element;
}
export declare class SurveyQuestionCheckboxItem extends ReactSurveyElement {
    constructor(props: any);
    protected getStateElement(): Base;
    protected get question(): QuestionCheckboxModel;
    protected get item(): ItemValue;
    protected get textStyle(): any;
    protected get isFirst(): any;
    protected get index(): number;
    shouldComponentUpdate(): boolean;
    handleOnChange: (event: any) => void;
    selectAllChanged: (event: any) => void;
    protected canRender(): boolean;
    protected renderElement(): JSX.Element;
    protected get inputStyle(): any;
    protected renderCheckbox(isChecked: boolean, otherItem: JSX.Element): JSX.Element;
    protected renderOther(): JSX.Element;
}

export declare class SurveyQuestionRanking extends SurveyQuestionElementBase {
    protected get question(): QuestionRankingModel;
    protected renderElement(): JSX.Element;
    protected getItems(): Array<any>;
    protected renderItem(item: ItemValue, i: number, handleKeydown: (event: any) => void, handlePointerDown: (event: PointerEvent) => void, cssClasses: any, itemClass: string, question: QuestionRankingModel): JSX.Element;
}
export declare class SurveyQuestionRankingItem extends ReactSurveyElement {
    protected get text(): string;
    protected get index(): string;
    protected get indexText(): string;
    protected get handleKeydown(): (event: any) => void;
    protected get handlePointerDown(): (event: any) => void;
    protected get cssClasses(): any;
    protected get itemClass(): string;
    protected get question(): any;
    protected renderElement(): JSX.Element;
}

export declare class SurveyQuestionDropdown extends SurveyQuestionUncontrolledElement<QuestionDropdownModel> {
    constructor(props: any);
    protected setValueCore(newValue: any): void;
    protected getValueCore(): any;
    protected renderElement(): JSX.Element;
    protected renderSelect(cssClasses: any): JSX.Element;
    protected renderOther(cssClasses: any): JSX.Element;
}
export declare class SurveyQuestionOptionItem extends ReactSurveyElement {
    constructor(props: any);
    protected getStateElement(): Base;
    protected canRender(): boolean;
    protected renderElement(): JSX.Element;
}

export declare class SurveyQuestionMatrix extends SurveyQuestionElementBase {
    constructor(props: any);
    protected get question(): QuestionMatrixModel;
    componentDidMount(): void;
    componentWillUnmount(): void;
    protected renderElement(): JSX.Element;
}
export declare class SurveyQuestionMatrixRow extends ReactSurveyElement {
    constructor(props: any);
    handleOnChange(event: any): void;
    protected wrapCell(cell: any, element: JSX.Element, reason: string): JSX.Element;
    protected canRender(): boolean;
    protected renderElement(): JSX.Element;
    generateTds(): JSX.Element[];
    cellClick(row: any, column: any): void;
}

export declare class SurveyQuestionHtml extends SurveyQuestionElementBase {
    constructor(props: any);
    protected get question(): QuestionHtmlModel;
    protected canRender(): boolean;
    protected renderElement(): JSX.Element;
}

export declare class SurveyQuestionFile extends SurveyQuestionElementBase {
    constructor(props: any);
    protected get question(): QuestionFileModel;
    protected renderElement(): JSX.Element;
    protected renderFileDecorator(): JSX.Element;
    protected renderClearButton(className: string): JSX.Element;
    protected renderPreview(): JSX.Element;
}

export declare class SurveyQuestionMultipleText extends SurveyQuestionElementBase {
    constructor(props: any);
    protected get question(): QuestionMultipleTextModel;
    protected renderElement(): JSX.Element;
    protected renderItemTooltipError(item: MultipleTextItemModel, cssClasses: any): JSX.Element;
    protected renderRow(rowIndex: number, items: Array<MultipleTextItemModel>, cssClasses: any): JSX.Element;
}
export declare class SurveyMultipleTextItemEditor extends SurveyQuestionAndErrorsWrapped {
    protected renderElement(): JSX.Element;
}

export declare class SurveyQuestionRadiogroup extends SurveyQuestionElementBase {
    constructor(props: any);
    protected get question(): QuestionRadiogroupModel;
    protected renderElement(): JSX.Element;
    protected getColumns(cssClasses: any): JSX.Element[];
    protected getItems(cssClasses: any): Array<any>;
    protected get textStyle(): any;
}
export declare class SurveyQuestionRadioItem extends ReactSurveyElement {
    constructor(props: any);
    protected getStateElement(): Base;
    protected get question(): QuestionRadiogroupModel;
    protected get item(): ItemValue;
    protected get textStyle(): any;
    protected get index(): number;
    protected get isChecked(): boolean;
    shouldComponentUpdate(): boolean;
    handleOnChange(event: any): void;
    protected canRender(): boolean;
    protected renderElement(): JSX.Element;
    protected renderOther(cssClasses: any): JSX.Element;
}

export declare class SurveyQuestionText extends SurveyQuestionUncontrolledElement<QuestionTextModel> {
    constructor(props: any);
    protected renderInput(): JSX.Element;
    protected renderElement(): JSX.Element;
}

export declare class SurveyQuestionBoolean extends SurveyQuestionElementBase {
    protected checkRef: React.RefObject<HTMLInputElement>;
    constructor(props: any);
    protected getStateElement(): Base;
    protected get question(): QuestionBooleanModel;
    handleOnChange(event: any): void;
    handleOnClick(event: any): void;
    handleOnSwitchClick(event: any): void;
    handleOnLabelClick(event: any, value: boolean): void;
    protected updateDomElement(): void;
    protected renderElement(): JSX.Element;
}

export declare class SurveyQuestionBooleanCheckbox extends SurveyQuestionBoolean {
    constructor(props: any);
    protected renderElement(): JSX.Element;
}

export declare class SurveyQuestionEmpty extends SurveyQuestionElementBase {
    constructor(props: any);
    protected get question(): QuestionEmptyModel;
    protected renderElement(): JSX.Element;
}

export declare class SurveyQuestionMatrixDropdownBase extends SurveyQuestionElementBase {
    constructor(props: any);
    protected get question(): QuestionMatrixDropdownModelBase;
    componentDidMount(): void;
    componentWillUnmount(): void;
    protected renderElement(): JSX.Element;
    renderTableDiv(): JSX.Element;
    renderHeader(): JSX.Element;
    renderFooter(): JSX.Element;
    renderRows(): JSX.Element;
    renderRow(keyValue: any, row: QuestionMatrixDropdownRenderedRow, cssClasses: any): JSX.Element;
    renderCell(cell: QuestionMatrixDropdownRenderedCell, index: number, cssClasses: any): JSX.Element;
}
export declare class SurveyQuestionMatrixDropdownCell extends SurveyQuestionAndErrorsCell {
    constructor(props: any);
    protected getQuestion(): Question;
    protected doAfterRender(): void;
    protected getShowErrors(): boolean;
    protected getCellStyle(): any;
    protected getHeaderText(): string;
    protected renderQuestion(): JSX.Element;
}

export declare class SurveyQuestionMatrixDropdown extends SurveyQuestionMatrixDropdownBase {
    constructor(props: any);
}

export declare class SurveyQuestionMatrixDynamic extends SurveyQuestionMatrixDropdownBase {
    constructor(props: any);
    protected get matrix(): QuestionMatrixDynamicModel;
    handleOnRowAddClick(event: any): void;
    protected renderElement(): JSX.Element;
    protected renderAddRowButtonOnTop(cssClasses: any): JSX.Element;
    protected renderAddRowButtonOnBottom(cssClasses: any): JSX.Element;
    protected renderNoRowsContent(cssClasses: any): JSX.Element;
    protected renderAddRowButton(cssClasses: any, isEmptySection?: boolean): JSX.Element;
}

export declare class SurveyQuestionPanelDynamic extends SurveyQuestionElementBase {
    constructor(props: any);
    protected get question(): QuestionPanelDynamicModel;
    componentDidMount(): void;
    componentWillUnmount(): void;
    handleOnPanelAddClick(event: any): void;
    handleOnPanelPrevClick(event: any): void;
    handleOnPanelNextClick(event: any): void;
    handleOnRangeChange(event: any): void;
    protected renderElement(): JSX.Element;
    protected renderNavigator(): JSX.Element;
    protected rendrerPrevButton(): JSX.Element;
    protected rendrerNextButton(): JSX.Element;
    protected renderRange(): JSX.Element;
    protected renderAddRowButton(): JSX.Element;
    protected renderNavigatorV2(): JSX.Element;
}
export declare class SurveyQuestionPanelDynamicItem extends SurveyPanel {
    constructor(props: any);
    protected getSurvey(): SurveyModel;
    protected getCss(): any;
    handleOnPanelRemoveClick(event: any): void;
    render(): JSX.Element;
    protected renderButton(): JSX.Element;
}

export declare class SurveyProgress extends SurveyNavigationBase {
    constructor(props: any);
    protected get isTop(): boolean;
    protected get progress(): number;
    protected get progressText(): string;
    render(): JSX.Element;
}

export declare class SurveyProgressButtons extends SurveyNavigationBase {
    constructor(props: any);
    render(): JSX.Element;
    protected getListElements(): JSX.Element[];
    protected renderListElement(page: PageModel, index: number): JSX.Element;
    protected isListElementClickable(index: number): boolean;
    protected getListElementCss(index: number): string;
    protected clickListElement(index: number): void;
    protected getScrollButtonCss(isLeftScroll: boolean): string;
    protected clickScrollButton(listContainerElement: Element, isLeftScroll: boolean): void;
    componentDidMount(): void;
    componentWillUnmount(): void;
}

export declare class SurveyQuestionRating extends SurveyQuestionElementBase {
    constructor(props: any);
    protected get question(): QuestionRatingModel;
    handleOnClick(event: any): void;
    protected renderElement(): JSX.Element;
    protected renderItem(key: string, item: ItemValue, index: number, minText: JSX.Element, maxText: JSX.Element, cssClasses: any): JSX.Element;
    protected renderOther(cssClasses: any): JSX.Element;
}

export declare class SurveyQuestionExpression extends SurveyQuestionElementBase {
    constructor(props: any);
    protected get question(): QuestionExpressionModel;
    protected renderElement(): JSX.Element;
}

export declare class SurveyWindow extends Survey {
    protected window: ReactWindowModel;
    constructor(props: any);
    protected getStateElements(): Array<Base>;
    handleOnExpanded(event: any): void;
    protected canRender(): boolean;
    protected renderElement(): JSX.Element;
    protected renderWindowHeader(): JSX.Element;
    protected renderBody(): JSX.Element;
    protected createSurvey(newProps: any): void;
}

export declare class ReactQuestionFactory {
    static Instance: ReactQuestionFactory;
    registerQuestion(questionType: string, questionCreator: (name: string) => JSX.Element): void;
    getAllTypes(): Array<string>;
    createQuestion(questionType: string, params: any): JSX.Element;
}

export declare class ReactElementFactory {
    static Instance: ReactElementFactory;
    registerElement(elementType: string, elementCreator: (props: any) => JSX.Element): void;
    getAllTypes(): Array<string>;
    isElementRegistered(elementType: string): boolean;
    createElement(elementType: string, params: any): JSX.Element;
}

export declare class SurveyQuestionImagePicker extends SurveyQuestionElementBase {
    constructor(props: any);
    protected get question(): QuestionImagePickerModel;
    handleOnChange(event: any): void;
    protected renderElement(): JSX.Element;
    protected getItems(cssClasses: any): Array<any>;
    protected get textStyle(): any;
    protected renderItem(key: string, item: ItemValue, cssClasses: any): JSX.Element;
}

export declare class SurveyQuestionImage extends SurveyQuestionElementBase {
    constructor(props: any);
    componentDidMount(): void;
    componentWillUnmount(): void;
    protected get question(): QuestionImageModel;
    protected canRender(): boolean;
    protected renderElement(): JSX.Element;
}

export declare class SurveyQuestionSignaturePad extends SurveyQuestionElementBase {
    constructor(props: any);
    protected get question(): QuestionSignaturePadModel;
    protected renderElement(): JSX.Element;
}

export declare class SurveyQuestionButtonGroup extends SurveyQuestionElementBase {
    constructor(props: any);
    protected get question(): QuestionButtonGroupModel;
    getStateElement(): QuestionButtonGroupModel;
    render(): JSX.Element;
    renderItems(): JSX.Element[];
}
export declare class SurveyButtonGroupItem extends SurveyElementBase<any, any> {
    model: ButtonGroupItemModel;
    constructor(props: any);
    get index(): number;
    get question(): QuestionButtonGroupModel;
    get item(): ButtonGroupItemValue;
    getStateElement(): ButtonGroupItemValue;
    render(): JSX.Element;
    protected renderIcon(): JSX.Element;
    protected renderInput(): JSX.Element;
    protected renderCaption(): JSX.Element;
}

export declare class SurveyQuestionCustom extends SurveyQuestionUncontrolledElement<QuestionCustomModel> {
    constructor(props: any);
    protected getStateElements(): Array<Base>;
    protected renderElement(): JSX.Element;
}
export declare class SurveyQuestionComposite extends SurveyQuestionUncontrolledElement<QuestionCompositeModel> {
    constructor(props: any);
    protected canRender(): boolean;
    protected renderElement(): JSX.Element;
}

export declare class DefaultTitle extends React.Component<any, any> {
    protected get cssClasses(): any;
    protected get element(): Question;
    render(): JSX.Element;
    componentDidMount(): void;
}

interface IPopupProps {
    model: PopupModel;
}
export declare class Popup extends SurveyElementBase<IPopupProps, any> {
    constructor(props: IPopupProps);
    get model(): PopupModel;
    protected getStateElement(): PopupModel<any>;
    componentDidMount(): void;
    componentWillUnmount(): void;
    shouldComponentUpdate(nextProps: IPopupProps): boolean;
    render(): JSX.Element;
}
export declare class PopupContainer extends SurveyElementBase<any, any> {
    prevIsVisible: boolean;
    constructor(props: any);
    handleKeydown: (event: any) => void;
    get model(): PopupBaseViewModel;
    protected getStateElement(): PopupBaseViewModel;
    clickInside: (ev: any) => void;
    componentDidUpdate(prevProps: any, prevState: any): void;
    renderContainer(): JSX.Element;
    renderPointer(): JSX.Element;
    renderHeader(): JSX.Element;
    renderContent(): JSX.Element;
    renderCancelButton(): JSX.Element;
    renderApplyButton(): JSX.Element;
    renderFooter(): JSX.Element;
    render(): JSX.Element;
}
export declare function showModal(componentName: string, data: any, onApply: () => boolean, onCancel?: () => void, cssClass?: string, title?: string, displayMode?: "popup" | "overlay"): void;
export {};

interface IListProps {
    model: ListModel;
}
export declare class List extends SurveyElementBase<IListProps, any> {
    get model(): ListModel;
    handleKeydown: (event: any) => void;
    getStateElement(): ListModel;
    render(): JSX.Element;
    renderItems(): JSX.Element[];
    searchElementContent(): JSX.Element;
}
export {};

export declare class TitleActions extends React.Component<any, any> {
    protected get cssClasses(): any;
    protected get element(): SurveyElement;
    render(): JSX.Element;
}

export declare class TitleElement extends React.Component<any, any> {
    constructor(props: any);
    render(): JSX.Element;
}

interface IActionBarProps {
    model: ActionContainer<Action>;
    handleClick?: boolean;
}
export declare class SurveyActionBar extends SurveyElementBase<IActionBarProps, any> {
    constructor(props: IActionBarProps);
    get model(): ActionContainer<Action>;
    componentDidMount(): void;
    componentWillUnmount(): void;
    protected getStateElement(): Base;
    renderElement(): any;
    renderItems(): JSX.Element[];
}

interface ILogoImageProps {
    data: SurveyModel;
}
export declare class LogoImage extends React.Component<ILogoImageProps, any> {
    constructor(props: ILogoImageProps);
    render(): JSX.Element;
}
export {};

interface ISurveyHeaderProps {
    survey: SurveyModel;
}
export declare class SurveyHeader extends React.Component<ISurveyHeaderProps, any> {
    constructor(props: ISurveyHeaderProps);
    componentDidMount(): void;
    componentWillUnmount(): void;
    render(): JSX.Element;
}
export {};

export declare class SvgIcon extends React.Component<any, any> {
    constructor(props: any);
    updateSvg(): void;
    componentDidUpdate(): void;
    render(): JSX.Element;
    componentDidMount(): void;
}

export declare class SurveyQuestionMatrixDynamicRemoveButton extends ReactSurveyElement {
    constructor(props: any);
    handleOnRowRemoveClick(event: any): void;
    protected renderElement(): JSX.Element;
}

export declare class SurveyQuestionMatrixDetailButton extends ReactSurveyElement {
    constructor(props: any);
    protected getStateElement(): any;
    get item(): Action;
    handleOnShowHideClick(event: any): void;
    protected renderElement(): JSX.Element;
}

export declare class SurveyQuestionMatrixDynamicDragDropIcon extends ReactSurveyElement {
    onPointerDownHandler(event: any): void;
    protected renderElement(): JSX.Element;
}

interface IMAtrixRowProps {
    model: QuestionMatrixDropdownRenderedRow;
}
export declare class MatrixRow extends SurveyElementBase<IMAtrixRowProps, any> {
    constructor(props: IMAtrixRowProps);
    get model(): QuestionMatrixDropdownRenderedRow;
    protected getStateElement(): QuestionMatrixDropdownRenderedRow;
    render(): JSX.Element;
}
export {};

export declare class Skeleton extends React.Component<any, any> {
    render(): JSX.Element;
}

export declare class SurveyLocStringViewer extends React.Component<any, any> {
    constructor(props: any);
    componentDidMount(): void;
    componentWillUnmount(): void;
    componentDidUpdate(prevProps: any, prevState: any): void;
    render(): JSX.Element;
}

export declare class SurveyLocStringEditor extends React.Component<any, any> {
    constructor(props: any);
    componentDidMount(): void;
    componentWillUnmount(): void;
    onInput: (event: any) => void;
    onClick: (event: any) => void;
    render(): JSX.Element;
}

interface IDimensions {
    scroll: number;
    offset: number;
}
export declare class ResponsivityManager {
    protected container: HTMLDivElement;
    protected minDimensionConst: number;
    protected recalcMinDimensionConst: boolean;
    getComputedStyle: (elt: Element) => CSSStyleDeclaration;
    constructor(container: HTMLDivElement, model: AdaptiveActionContainer, itemsSelector: string, dotsItemSize?: number);
    protected getDimensions(element: HTMLElement): IDimensions;
    protected getAvailableSpace(): number;
    protected calcItemSize(item: HTMLDivElement): number;
    dispose(): void;
}
export declare class VerticalResponsivityManager extends ResponsivityManager {
    constructor(container: HTMLDivElement, model: AdaptiveActionContainer, itemsSelector: string, dotsItemSize?: number);
    protected getDimensions(): IDimensions;
    protected getAvailableSpace(): number;
    protected calcItemSize(item: HTMLDivElement): number;
}
export {};

declare function compareVersions(a: any, b: any): number;
declare function confirmAction(message: string): boolean;
declare function detectIEBrowser(): boolean;
declare function detectIEOrEdge(): any;
declare function loadFileFromBase64(b64Data: string, fileName: string): void;
declare function isMobile(): boolean;
declare function isElementVisible(element: HTMLElement, threshold?: number): boolean;
declare function findScrollableParent(element: HTMLElement): HTMLElement;
declare function scrollElementByChildId(id: string): void;
declare function getIconNameFromProxy(iconName: string): string;
declare function createSvg(size: number | string, width: number, height: number, iconName: string, svgElem: any): void;
export declare function unwrap<T>(value: T | (() => T)): T;
export declare function getSize(value: any): any;
declare function doKey2ClickUp(evt: KeyboardEvent, options?: {
    processEsc: boolean;
}): void;
declare function doKey2ClickDown(evt: KeyboardEvent, options?: {
    processEsc: boolean;
}): void;
declare function increaseHeightByContent(element: HTMLElement, getComputedStyle?: (elt: Element) => any): void;
declare function getOriginalEvent(event: any): any;
declare function preventDefaults(event: any): void;
export { compareVersions, confirmAction, detectIEOrEdge, detectIEBrowser, loadFileFromBase64, isMobile, isElementVisible, findScrollableParent, scrollElementByChildId, createSvg, doKey2ClickUp, doKey2ClickDown, getIconNameFromProxy, increaseHeightByContent, getOriginalEvent, preventDefaults };

export declare class SurveyPanelBase extends SurveyElementBase<any, any> {
    protected rootRef: React.RefObject<HTMLDivElement>;
    constructor(props: any);
    protected getStateElement(): Base;
    protected canUsePropInState(key: string): boolean;
    protected get survey(): SurveyModel;
    protected get creator(): ISurveyCreator;
    protected get css(): any;
    get panelBase(): PanelModelBase;
    protected getPanelBase(): PanelModelBase;
    protected getSurvey(): SurveyModel;
    protected getCss(): any;
    componentDidMount(): void;
    componentWillUnmount(): void;
    componentDidUpdate(prevProps: any, prevState: any): void;
    protected canRender(): boolean;
    protected renderRows(css: any): Array<JSX.Element>;
    protected createRow(row: QuestionRowModel, css: any): JSX.Element;
}

/**
    * A Model for a checkbox question
    */
export declare class QuestionCheckboxModel extends QuestionCheckboxBase {
        constructor(name: string);
        get ariaRole(): string;
        getType(): string;
        protected onCreating(): void;
        protected getFirstInputElementId(): string;
        /**
            * Returns the select all item. By using this property, you may change programmatically it's value and text.
            * @see hasSelectAll
            */
        get selectAllItem(): ItemValue;
        /**
            * Use this property to set the different text for Select All item.
            */
        get selectAllText(): string;
        set selectAllText(val: string);
        get locSelectAllText(): LocalizableString;
        /**
            * Set this property to true, to show the "Select All" item on the top. If end-user checks this item, then all items are checked.
            */
        get hasSelectAll(): boolean;
        set hasSelectAll(val: boolean);
        /**
            * Returns true if all items are selected
            * @see toggleSelectAll
            */
        get isAllSelected(): boolean;
        set isAllSelected(val: boolean);
        /**
            * It will select all items, except other and none. If all items have been already selected then it will clear the value
            * @see isAllSelected
            * @see selectAll
            */
        toggleSelectAll(): void;
        /**
            * Select all items, except other and none.
            */
        selectAll(): void;
        /**
            * Returns true if item is checked
            * @param item checkbox item value
            */
        isItemSelected(item: ItemValue): boolean;
        /**
            * Set this property different to 0 to limit the number of selected choices in the checkbox.
            */
        get maxSelectedChoices(): number;
        set maxSelectedChoices(val: number);
        /**
            * Return the selected items in the checkbox. Returns empty array if the value is empty
            */
        get selectedItems(): Array<ItemValue>;
        protected onEnableItemCallBack(item: ItemValue): boolean;
        protected onAfterRunItemsEnableCondition(): void;
        protected getItemClassCore(item: any, options: any): string;
        updateValueFromSurvey(newValue: any): void;
        protected setNewValue(newValue: any): void;
        protected getIsMultipleValue(): boolean;
        protected getCommentFromValue(newValue: any): string;
        protected setOtherValueIntoValue(newValue: any): any;
        protected canUseFilteredChoices(): boolean;
        protected supportSelectAll(): boolean;
        protected addToVisibleChoices(items: Array<ItemValue>, isAddAll: boolean): void;
        protected isBuiltInChoice(item: ItemValue, question: QuestionSelectBase): boolean;
        /**
            * For internal use in SurveyJS Creator V2.
            */
        isItemInList(item: ItemValue): boolean;
        protected getDisplayValueCore(keysAsText: boolean, value: any): any;
        protected clearIncorrectValuesCore(): void;
        protected clearDisabledValuesCore(): void;
        getConditionJson(operator?: string, path?: string): any;
        isAnswerCorrect(): boolean;
        protected setDefaultValueWithOthers(): void;
        protected getHasOther(val: any): boolean;
        protected valueFromData(val: any): any;
        protected renderedValueFromDataCore(val: any): any;
        protected rendredValueToDataCore(val: any): any;
        get checkBoxSvgPath(): string;
}

export declare class Bindings {
        constructor(obj: Base);
        getType(): string;
        getNames(): Array<string>;
        getProperties(): Array<JsonObjectProperty>;
        setBinding(propertyName: string, valueName: string): void;
        clearBinding(propertyName: string): void;
        isEmpty(): boolean;
        getValueNameByPropertyName(propertyName: string): string;
        getPropertiesByValueName(valueName: string): Array<string>;
        getJson(): any;
        setJson(value: any): void;
}
export declare class Dependencies {
        currentDependency: () => void;
        target: Base;
        property: string;
        constructor(currentDependency: () => void, target: Base, property: string);
        dependencies: Array<{
                obj: Base;
                prop: string;
                id: string;
        }>;
        id: string;
        addDependency(target: Base, property: string): void;
        dispose(): void;
}
export declare class ComputedUpdater<T = any> {
        static readonly ComputedUpdaterType = "__dependency_computed";
        constructor(_updater: () => T);
        readonly type = "__dependency_computed";
        get updater(): () => T;
        setDependencies(dependencies: Dependencies): void;
        protected getDependencies(): Dependencies;
        dispose(): any;
}
/**
    * The base class for SurveyJS objects.
    */
export declare class Base {
        static finishCollectDependencies(): Dependencies;
        static startCollectDependencies(updater: () => void, target: Base, property: string): void;
        static get commentPrefix(): string;
        static set commentPrefix(val: string);
        static createItemValue: (item: any, type?: string) => any;
        static itemValueLocStrChanged: (arr: Array<any>) => void;
        /**
            * Returns true if a value undefined, null, empty string or empty array.
            *
            * @param value
            * @param trimString a boolean parameter, default value true. If true then it trims the string and functions returns true for a string that contains white spaces only.
            */
        isValueEmpty(value: any, trimString?: boolean): boolean;
        protected trimValue(value: any): any;
        protected IsPropertyEmpty(value: any): boolean;
        protected isLoadingFromJsonValue: boolean;
        loadingOwner: Base;
        /**
            * Event that raise on property change of the sender object
            * sender - the object that owns the property
            * options.name - the property name that has been changed
            * options.oldValue - old value. Please note, it equals to options.newValue if property is an array
            * options.newValue - new value.
            */
        onPropertyChanged: EventBase<Base>;
        /**
            * Event that raised on changing property of the ItemValue object.
            * sender - the object that owns the property
            * options.propertyName - the property name to which ItemValue array is belong. It can be "choices" for dropdown question
            * options.obj - the instance of ItemValue object which property has been changed
            * options.name - the property of ItemObject that has been changed
            * options.oldValue - old value
            * options.newValue - new value
            */
        onItemValuePropertyChanged: Event<(sender: Base, options: any) => any, any>;
        getPropertyValueCoreHandler: (propertiesHash: any, name: string) => any;
        setPropertyValueCoreHandler: (propertiesHash: any, name: string, val: any) => void;
        createArrayCoreHandler: (propertiesHash: any, name: string) => Array<any>;
        surveyChangedCallback: () => void;
        constructor();
        dispose(): void;
        get isDisposed(): boolean;
        protected addEvent<T>(): EventBase<T>;
        protected onBaseCreating(): void;
        /**
            * Returns the type of the object as a string as it represents in the json. It should be in lowcase.
            */
        getType(): string;
        getSurvey(isLive?: boolean): ISurvey;
        /**
            * Returns true if the object is inluded into survey, otherwise returns false.
            */
        get inSurvey(): boolean;
        get bindings(): Bindings;
        checkBindings(valueName: string, value: any): void;
        protected updateBindings(propertyName: string, value: any): void;
        protected updateBindingValue(valueName: string, value: any): void;
        /**
            * Returns the element template name without prefix. Typically it equals to getType().
            * @see getType
            */
        getTemplate(): string;
        /**
            * Returns true if the object is loading from Json at the current moment.
            */
        get isLoadingFromJson(): boolean;
        protected getIsLoadingFromJson(): boolean;
        startLoadingFromJson(): void;
        endLoadingFromJson(): void;
        /**
            * Deserialized the current object into JSON
            * @see fromJSON
            */
        toJSON(): any;
        /**
            * Load object properties and elements. It doesn't reset properties that was changed before and they are not defined in the json parameter.
            * @param json the object JSON definition
            * @see toJSON
            */
        fromJSON(json: any): void;
        onSurveyLoad(): void;
        /**
            * Make a clone of the existing object. Create a new object of the same type and load all properties into it.
            */
        clone(): Base;
        /**
            * Returns the serializable property that belongs to this instance by property name. It returns null if the property is not exists.
            * @param propName property name
            * @returns
            */
        getPropertyByName(propName: string): JsonObjectProperty;
        isPropertyVisible(propName: string): boolean;
        static createProgressInfo(): IProgressInfo;
        getProgressInfo(): IProgressInfo;
        localeChanged(): void;
        locStrsChanged(): void;
        /**
            * Returns the property value by name
            * @param name property name
            */
        getPropertyValue(name: string, defaultValue?: any): any;
        protected getPropertyValueCore(propertiesHash: any, name: string): any;
        geValueFromHash(): any;
        protected setPropertyValueCore(propertiesHash: any, name: string, val: any): void;
        protected get isEditingSurveyElement(): boolean;
        iteratePropertiesHash(func: (hash: any, key: any) => void): void;
        /**
            * set property value
            * @param name property name
            * @param val new property value
            */
        setPropertyValue(name: string, val: any): void;
        protected setArrayPropertyDirectly(name: string, val: any, sendNotification?: boolean): void;
        protected setPropertyValueDirectly(name: string, val: any): void;
        protected clearPropertyValue(name: string): void;
        onPropertyValueChangedCallback(name: string, oldValue: any, newValue: any, sender: Base, arrayChanges: ArrayChanges): void;
        itemValuePropertyChanged(item: ItemValue, name: string, oldValue: any, newValue: any): void;
        protected onPropertyValueChanged(name: string, oldValue: any, newValue: any): void;
        protected propertyValueChanged(name: string, oldValue: any, newValue: any, arrayChanges?: ArrayChanges, target?: Base): void;
        protected get isInternal(): boolean;
        /**
            * Register a function that will be called on a property value changed.
            * @param name the property name
            * @param func the function with no parameters that will be called on property changed.
            * @param key an optional parameter. If there is already a registered function for this property with the same key, it will be overwritten.
            */
        registerFunctionOnPropertyValueChanged(name: string, func: any, key?: string): void;
        /**
            * Register a function that will be called on a property value changed from the names list.
            * @param names the list of properties names
            * @param func the function with no parameters that will be called on property changed.
            * @param key an optional parameter. If there is already a registered function for this property with the same key, it will be overwritten.
            */
        registerFunctionOnPropertiesValueChanged(names: Array<string>, func: any, key?: string): void;
        /**
            * Unregister notification on property value changed
            * @param name the property name
            * @param key the key with which you have registered the notification for this property. It can be null.
            */
        unRegisterFunctionOnPropertyValueChanged(name: string, key?: string): void;
        /**
            * Unregister notification on property value changed for all properties in the names list.
            * @param names the list of properties names
            * @param key the key with which you have registered the notification for this property. It can be null.
            */
        unRegisterFunctionOnPropertiesValueChanged(names: Array<string>, key?: string): void;
        createCustomLocalizableObj(name: string): void;
        protected createLocalizableString(name: string, owner: ILocalizableOwner, useMarkDown?: boolean, defaultStr?: boolean | string): LocalizableString;
        getLocalizableString(name: string): LocalizableString;
        getLocalizableStringText(name: string, defaultStr?: string): string;
        setLocalizableStringText(name: string, value: string): void;
        addUsedLocales(locales: Array<string>): void;
        searchText(text: string, founded: Array<IFindElement>): void;
        protected getSearchableLocKeys(keys: Array<string>): void;
        protected getSearchableItemValueKeys(keys: Array<string>): void;
        protected AddLocStringToUsedLocales(locStr: LocalizableString, locales: Array<string>): void;
        protected createItemValues(name: string): Array<any>;
        protected createNewArrayCore(name: string): Array<any>;
        protected ensureArray(name: string, onPush?: any, onRemove?: any): any[];
        protected createNewArray(name: string, onPush?: any, onRemove?: any): Array<any>;
        protected getItemValueType(): string;
        protected setArray(name: string, src: any[], dest: any[], isItemValues: boolean, onPush: any): void;
        protected isTwoValueEquals(x: any, y: any, caseInSensitive?: boolean, trimString?: boolean): boolean;
        protected copyCssClasses(dest: any, source: any): void;
}
export declare class ArrayChanges {
        index: number;
        deleteCount: number;
        itemsToAdd: any[];
        deletedItems: any[];
        constructor(index: number, deleteCount: number, itemsToAdd: any[], deletedItems: any[]);
}
export declare class Event<T extends Function, Options> {
        onCallbacksChanged: () => void;
        protected callbacks: Array<T>;
        get isEmpty(): boolean;
        fire(sender: any, options: Options): void;
        clear(): void;
        add(func: T): void;
        remove(func: T): void;
        hasFunc(func: T): boolean;
}
export declare class EventBase<T> extends Event<(sender: T, options: any) => any, any> {
}

/**
  * Array of ItemValue is used in checkox, dropdown and radiogroup choices, matrix columns and rows.
  * It has two main properties: value and text. If text is empty, value is used for displaying.
  * The text property is localizable and support markdown.
  */
export declare class ItemValue extends Base implements IShortcutText {
    protected typeName: string;
    [index: string]: any;
    static get Separator(): string;
    static set Separator(val: string);
    static createArray(locOwner: ILocalizableOwner): Array<ItemValue>;
    static setupArray(items: Array<ItemValue>, locOwner: ILocalizableOwner): void;
    static setData(items: Array<ItemValue>, values: Array<any>): void;
    static getData(items: Array<ItemValue>): any;
    static getItemByValue(items: Array<ItemValue>, val: any): ItemValue;
    static getTextOrHtmlByValue(items: Array<ItemValue>, val: any): string;
    static locStrsChanged(items: Array<ItemValue>): void;
    static runConditionsForItems(items: Array<ItemValue>, filteredItems: Array<ItemValue>, runner: ConditionRunner, values: any, properties: any, useItemExpression?: boolean): boolean;
    static runEnabledConditionsForItems(items: Array<ItemValue>, runner: ConditionRunner, values: any, properties: any, onItemCallBack?: (item: ItemValue) => boolean): boolean;
    ownerPropertyName: string;
    constructor(value: any, text?: string, typeName?: string);
    onCreating(): any;
    getType(): string;
    getSurvey(live?: boolean): ISurvey;
    getLocale(): string;
    get locText(): LocalizableString;
    setLocText(locText: LocalizableString): void;
    get locOwner(): ILocalizableOwner;
    set locOwner(value: ILocalizableOwner);
    get value(): any;
    set value(newValue: any);
    get hasText(): boolean;
    get pureText(): string;
    set pureText(val: string);
    get text(): string;
    set text(newText: string);
    get calculatedText(): string;
    get shortcutText(): string;
    getData(): any;
    toJSON(): any;
    setData(value: any): void;
    get visibleIf(): string;
    set visibleIf(val: string);
    get enableIf(): string;
    set enableIf(val: string);
    get isVisible(): boolean;
    setIsVisible(val: boolean): void;
    get isEnabled(): any;
    setIsEnabled(val: boolean): void;
    addUsedLocales(locales: Array<string>): void;
    locStrsChanged(): void;
    protected onPropertyValueChanged(name: string, oldValue: any, newValue: any): void;
    protected getConditionRunner(isVisible: boolean): ConditionRunner;
    originalItem: any;
}

export declare class SurveyActionBarItemDropdown extends SurveyActionBarItem {
    renderButtonContent(): JSX.Element;
}

export declare class SurveyActionBarSeparator extends React.Component<any, any> {
    constructor(props: any);
    render(): JSX.Element;
}

export declare class AdaptiveActionContainer<T extends Action = Action> extends ActionContainer<T> {
    protected dotsItem: Action;
    protected dotsItemPopupModel: PopupModel;
    minVisibleItemsCount: number;
    protected invisibleItemsListModel: ListModel;
    constructor();
    protected onSet(): void;
    protected onPush(item: T): void;
    protected getRenderedActions(): Array<T>;
    fit(dimension: number, dotsItemSize: number): void;
    initResponsivityManager(container: HTMLDivElement): void;
    resetResponsivityManager(): void;
    dispose(): void;
}

/**
    * It is a base class for checkbox, dropdown and radiogroup questions.
    */
export declare class QuestionSelectBase extends Question {
        visibleChoicesChangedCallback: () => void;
        constructor(name: string);
        getType(): string;
        dispose(): void;
        protected getItemValueType(): string;
        createItemValue(value: any): ItemValue;
        supportGoNextPageError(): boolean;
        isLayoutTypeSupported(layoutType: string): boolean;
        localeChanged(): void;
        locStrsChanged(): void;
        /**
            * Returns the other item. By using this property, you may change programmatically it's value and text.
            * @see hasOther
            */
        get otherItem(): ItemValue;
        /**
            * Returns true if a user select the 'other' item.
            */
        get isOtherSelected(): boolean;
        /**
            * Set this property to true, to show the "None" item on the bottom. If end-user checks this item, all other items would be unchecked.
            */
        get hasNone(): boolean;
        set hasNone(val: boolean);
        /**
            * Returns the none item. By using this property, you may change programmatically it's value and text.
            * @see hasNone
            */
        get noneItem(): ItemValue;
        /**
            * Use this property to set the different text for none item.
            */
        get noneText(): string;
        set noneText(val: string);
        get locNoneText(): LocalizableString;
        /**
            * An expression that returns true or false. It runs against each choices item and if for this item it returns true, then the item is visible otherwise the item becomes invisible. Please use {item} to get the current item value in the expression.
            * @see visibleIf
            * @see choicesEnableIf
            */
        get choicesVisibleIf(): string;
        set choicesVisibleIf(val: string);
        /**
            * An expression that returns true or false. It runs against each choices item and if for this item it returns true, then the item is enabled otherwise the item becomes disabled. Please use {item} to get the current item value in the expression.
            * @see choicesVisibleIf
            */
        get choicesEnableIf(): string;
        set choicesEnableIf(val: string);
        runCondition(values: HashTable<any>, properties: HashTable<any>): void;
        protected isTextValue(): boolean;
        protected setDefaultValue(): void;
        protected getIsMultipleValue(): boolean;
        protected convertDefaultValue(val: any): any;
        protected filterItems(): boolean;
        protected runItemsCondition(values: HashTable<any>, properties: HashTable<any>): boolean;
        protected runItemsEnableCondition(values: HashTable<any>, properties: HashTable<any>): any;
        protected onAfterRunItemsEnableCondition(): void;
        protected onEnableItemCallBack(item: ItemValue): boolean;
        protected getHasOther(val: any): boolean;
        get validatedValue(): any;
        protected createRestful(): ChoicesRestful;
        protected getQuestionComment(): string;
        protected setQuestionComment(newValue: string): void;
        clearValue(): void;
        updateCommentFromSurvey(newValue: any): any;
        get renderedValue(): any;
        set renderedValue(val: any);
        protected setQuestionValue(newValue: any, updateIsAnswered?: boolean, updateComment?: boolean): void;
        protected setNewValue(newValue: any): void;
        protected valueFromData(val: any): any;
        protected rendredValueFromData(val: any): any;
        protected rendredValueToData(val: any): any;
        protected renderedValueFromDataCore(val: any): any;
        protected rendredValueToDataCore(val: any): any;
        protected hasUnknownValue(val: any, includeOther?: boolean, isFilteredChoices?: boolean, checkEmptyValue?: boolean): boolean;
        protected isValueDisabled(val: any): boolean;
        /**
            * If the clearIncorrectValuesCallback is set, it is used to clear incorrect values instead of default behaviour.
            */
        clearIncorrectValuesCallback: () => void;
        /**
            * Use this property to fill the choices from a RESTful service.
            * @see choices
            * @see ChoicesRestful
            * @see [Example: RESTful Dropdown](https://surveyjs.io/Examples/Library/?id=questiontype-dropdownrestfull)
            * @see [Docs: Fill Choices from a RESTful Service](https://surveyjs.io/Documentation/Library/?id=LibraryOverview#fill-the-choices-from-a-restful-service)
            */
        get choicesByUrl(): ChoicesRestful;
        set choicesByUrl(val: ChoicesRestful);
        /**
            * The list of items. Every item has value and text. If text is empty, the value is rendered. The item text supports markdown.
            * @see choicesByUrl
            * @see choicesFromQuestion
            */
        get choices(): Array<any>;
        set choices(newValue: Array<any>);
        /**
            * Set this property to get choices from the specified question instead of defining them in the current question. This avoids duplication of choices declaration in your survey definition.
            * By setting this property, the "choices", "choicesVisibleIf", "choicesEnableIf" and "choicesOrder" properties become invisible, because these question characteristics depend on actions in another (specified) question.
            * Use the `choicesFromQuestionMode` property to filter choices obtained from the specified question.
            * @see choices
            * @see choicesFromQuestionMode
            */
        get choicesFromQuestion(): string;
        set choicesFromQuestion(val: string);
        /**
            * This property becomes visible when the `choicesFromQuestion` property is selected. The default value is "all" (all visible choices from another question are displayed as they are).
            * You can set this property to "selected" or "unselected" to display only selected or unselected choices from the specified question.
            * @see choicesFromQuestion
            */
        get choicesFromQuestionMode(): string;
        set choicesFromQuestionMode(val: string);
        /**
            * Set this property to true to hide the question if there is no visible choices.
            */
        get hideIfChoicesEmpty(): boolean;
        set hideIfChoicesEmpty(val: boolean);
        get keepIncorrectValues(): boolean;
        set keepIncorrectValues(val: boolean);
        /**
            * Please use survey.storeOthersAsComment to change the behavior on the survey level. This property is depricated and invisible in Survey Creator.
            * By default the entered text in the others input in the checkbox/radiogroup/dropdown are stored as "question name " + "-Comment". The value itself is "question name": "others". Set this property to false, to store the entered text directly in the "question name" key.
            * Possible values are: "default", true, false
            * @see SurveyModel.storeOthersAsComment
            */
        get storeOthersAsComment(): any;
        set storeOthersAsComment(val: any);
        protected hasOtherChanged(): void;
        /**
            * Use this property to render items in a specific order: "asc", "desc", "random". Default value is "none".
            */
        get choicesOrder(): string;
        set choicesOrder(val: string);
        /**
            * Use this property to set the different text for other item.
            */
        get otherText(): string;
        set otherText(val: string);
        get locOtherText(): LocalizableString;
        /**
            *  Use this property to set the place holder text for other or comment field  .
            */
        otherPlaceHolder: string;
        /**
            * The text that shows when the other item is choosed by the other input is empty.
            */
        get otherErrorText(): string;
        set otherErrorText(val: string);
        get locOtherErrorText(): LocalizableString;
        /**
            * The list of items as they will be rendered. If needed items are sorted and the other item is added.
            * @see hasOther
            * @see choicesOrder
            * @see enabledChoices
            */
        get visibleChoices(): Array<ItemValue>;
        /**
            * The list of enabled items as they will be rendered. The disabled items are not included
            * @see hasOther
            * @see choicesOrder
            * @see visibleChoices
            */
        get enabledChoices(): Array<ItemValue>;
        protected updateVisibleChoices(): void;
        protected canUseFilteredChoices(): boolean;
        setCanShowOptionItemCallback(func: (item: ItemValue) => boolean): void;
        protected addToVisibleChoices(items: Array<ItemValue>, isAddAll: boolean): void;
        protected canShowOptionItem(item: ItemValue): boolean;
        /**
            * For internal use in SurveyJS Creator V2.
            */
        isItemInList(item: ItemValue): boolean;
        protected get isAddDefaultItems(): boolean;
        getPlainData(options?: {
                includeEmpty?: boolean;
                includeQuestionTypes?: boolean;
                calculations?: Array<{
                        propertyName: string;
                }>;
        }): any;
        /**
            * Returns the text for the current value. If the value is null then returns empty string. If 'other' is selected then returns the text for other value.
            */
        protected getDisplayValueCore(keysAsText: boolean, value: any): any;
        protected getDisplayValueEmpty(): string;
        protected getChoicesDisplayValue(items: ItemValue[], val: any): any;
        protected get activeChoices(): Array<ItemValue>;
        protected getChoicesFromQuestion(question: QuestionSelectBase): Array<ItemValue>;
        protected get hasActiveChoices(): boolean;
        protected isBuiltInChoice(item: ItemValue, question: QuestionSelectBase): boolean;
        protected getChoices(): Array<ItemValue>;
        supportComment(): boolean;
        supportOther(): boolean;
        supportNone(): boolean;
        protected isSupportProperty(propName: string): boolean;
        protected onCheckForErrors(errors: Array<SurveyError>, isOnValueChanged: boolean): void;
        setSurveyImpl(value: ISurveyImpl, isLight?: boolean): void;
        protected setSurveyCore(value: ISurvey): void;
        protected getStoreOthersAsComment(): boolean;
        onSurveyLoad(): void;
        onAnyValueChanged(name: string): void;
        updateValueFromSurvey(newValue: any): void;
        protected getCommentFromValue(newValue: any): string;
        protected setOtherValueIntoValue(newValue: any): any;
        protected onBeforeSendRequest(): void;
        protected onLoadChoicesFromUrl(array: Array<ItemValue>): void;
        protected updateChoicesDependedQuestions(): void;
        onSurveyValueChanged(newValue: any): void;
        protected onVisibleChoicesChanged(): void;
        clearIncorrectValues(): void;
        clearValueIfInvisible(): void;
        /**
            * Returns true if item is selected
            * @param item checkbox or radio item value
            */
        isItemSelected(item: ItemValue): boolean;
        protected clearIncorrectValuesCore(): void;
        protected canClearValueAnUnknow(val: any): boolean;
        protected clearDisabledValuesCore(): void;
        clearUnusedValues(): void;
        getColumnClass(): string;
        getItemIndex(item: any): number;
        getItemClass(item: any): string;
        protected getItemClassCore(item: any, options: any): string;
        getLabelClass(item: ItemValue): string;
        getControlLabelClass(item: ItemValue): string;
        get columns(): ItemValue[][];
        get hasColumns(): boolean;
        choicesLoaded(): void;
        getItemValueWrapperComponentName(item: ItemValue): string;
        getItemValueWrapperComponentData(item: ItemValue): any;
        ariaItemChecked(item: ItemValue): "true" | "false";
        isOtherItem(item: ItemValue): boolean;
        get itemSvgIcon(): string;
        ariaItemLabel(item: ItemValue): string;
        getItemId(item: ItemValue): string;
        get questionName(): string;
        getItemEnabled(item: ItemValue): any;
}
/**
    * A base class for checkbox and radiogroup questions. It introduced a colCount property.
    */
export declare class QuestionCheckboxBase extends QuestionSelectBase {
        colCountChangedCallback: () => void;
        constructor(name: string);
        /**
            * The number of columns for radiogroup and checkbox questions. Items are rendred in one line if the value is 0.
            */
        get colCount(): number;
        set colCount(value: number);
        protected onParentChanged(): void;
        protected onParentQuestionChanged(): void;
        protected getSearchableItemValueKeys(keys: Array<string>): void;
}

export interface ILocalizableOwner {
        getLocale(): string;
        getMarkdownHtml(text: string, name: string): string;
        getProcessedText(text: string): string;
        getRenderer(name: string): string;
        getRendererContext(locStr: LocalizableString): any;
}
export interface ILocalizableString {
        getLocaleText(loc: string): string;
        setLocaleText(loc: string, newValue: string): any;
        getJson(): any;
        getLocales(): Array<string>;
        getIsMultiple(): boolean;
}
/**
    * The class represents the string that supports multi-languages and markdown.
    * It uses in all objects where support for multi-languages and markdown is required.
    */
export declare class LocalizableString implements ILocalizableString {
        owner: ILocalizableOwner;
        useMarkdown: boolean;
        name?: string;
        static SerializeAsObject: boolean;
        static get defaultLocale(): string;
        static set defaultLocale(val: string);
        static defaultRenderer: string;
        static editableRenderer: string;
        localizationName: string;
        onGetTextCallback: (str: string) => string;
        onGetDefaultTextCallback: () => string;
        onStrChanged: (oldValue: string, newValue: string) => void;
        onSearchChanged: () => void;
        sharedData: LocalizableString;
        searchText: string;
        searchIndex: number;
        constructor(owner: ILocalizableOwner, useMarkdown?: boolean, name?: string);
        getIsMultiple(): boolean;
        get locale(): string;
        strChanged(): void;
        get text(): string;
        set text(value: string);
        get calculatedText(): string;
        get pureText(): string;
        get hasHtml(): boolean;
        get html(): string;
        get isEmpty(): boolean;
        get textOrHtml(): string;
        get renderedHtml(): string;
        getLocaleText(loc: string): string;
        setLocaleText(loc: string, value: string): void;
        hasNonDefaultText(): boolean;
        getLocales(): Array<string>;
        getJson(): any;
        setJson(value: any): void;
        get renderAs(): string;
        get renderAsData(): any;
        equals(obj: any): boolean;
        setFindText(text: string): boolean;
        onChanged(): void;
        protected onCreating(): void;
        getHtmlValue(): string;
}
/**
    * The class represents the list of strings that supports multi-languages.
    */
export declare class LocalizableStrings implements ILocalizableString {
        owner: ILocalizableOwner;
        onValueChanged: (oldValue: any, newValue: any) => void;
        constructor(owner: ILocalizableOwner);
        getIsMultiple(): boolean;
        get locale(): string;
        get value(): Array<string>;
        set value(val: Array<string>);
        get text(): string;
        set text(val: string);
        getLocaleText(loc: string): string;
        setLocaleText(loc: string, newValue: string): any;
        getValue(loc: string): Array<string>;
        setValue(loc: string, val: Array<string>): void;
        hasValue(loc?: string): boolean;
        get isEmpty(): boolean;
        getLocales(): Array<string>;
        getJson(): any;
        setJson(value: any): void;
}

export interface IPropertyDecoratorOptions {
        defaultValue?: any;
        defaultSource?: string;
        localizable?: {
                name?: string;
                onGetTextCallback?: (str: string) => string;
                defaultStr?: string;
        } | boolean;
        onSet?: (val: any, target: any) => void;
}
export declare function property(options?: IPropertyDecoratorOptions): (target: any, key: string) => void;
export interface IArrayPropertyDecoratorOptions {
        onPush?: any;
        onRemove?: any;
        onSet?: (val: any, target: any) => void;
}
export declare function propertyArray(options?: IArrayPropertyDecoratorOptions): (target: any, key: string) => void;
export interface IObject {
        [key: string]: any;
}
/**
    * Contains information about a property of a survey element (page, panel, questions, and etc).
    * @see addProperty
    * @see removeProperty
    * @see [Add Properties](https://surveyjs.io/Documentation/Survey-Creator#addproperties)
    * @see [Remove Properties](https://surveyjs.io/Documentation/Survey-Creator#removeproperties)
    */
export declare class JsonObjectProperty implements IObject {
        name: string;
        static getItemValuesDefaultValue: (val: any) => any;
        [key: string]: any;
        isSerializable: boolean;
        isLightSerializable: boolean;
        isCustom: boolean;
        isDynamicChoices: boolean;
        isBindable: boolean;
        className: string;
        alternativeName: string;
        classNamePart: string;
        baseClassName: string;
        defaultValueValue: any;
        serializationProperty: string;
        displayName: string;
        category: string;
        categoryIndex: number;
        visibleIndex: number;
        nextToProperty: string;
        showMode: string;
        maxLength: number;
        maxValue: any;
        minValue: any;
        layout: string;
        onGetValue: (obj: any) => any;
        onSetValue: (obj: any, value: any, jsonConv: JsonObject) => any;
        visibleIf: (obj: any) => boolean;
        onPropertyEditorUpdate: (obj: any, propEditor: any) => any;
        constructor(classInfo: JsonMetadataClass, name: string, isRequired?: boolean);
        get id(): number;
        get classInfo(): JsonMetadataClass;
        get type(): string;
        set type(value: string);
        isArray: boolean;
        get isRequired(): boolean;
        set isRequired(val: boolean);
        get isUnique(): boolean;
        set isUnique(val: boolean);
        get hasToUseGetValue(): string | ((obj: any) => any);
        get defaultValue(): any;
        set defaultValue(newValue: any);
        isDefaultValue(value: any): boolean;
        getValue(obj: any): any;
        getPropertyValue(obj: any): any;
        get hasToUseSetValue(): string | ((obj: any, value: any, jsonConv: JsonObject) => any);
        setValue(obj: any, value: any, jsonConv: JsonObject): void;
        getObjType(objType: string): string;
        getClassName(className: string): string;
        /**
            * Depricated, please use getChoices
            */
        get choices(): Array<any>;
        get hasChoices(): boolean;
        getChoices(obj: any, choicesCallback?: any): Array<any>;
        setChoices(value: Array<any>, valueFunc?: (obj: any) => Array<any>): void;
        getBaseValue(): string;
        setBaseValue(val: any): void;
        get readOnly(): boolean;
        set readOnly(val: boolean);
        isVisible(layout: string, obj?: any): boolean;
        get visible(): boolean;
        set visible(val: boolean);
        get isLocalizable(): boolean;
        set isLocalizable(val: boolean);
        get dataList(): Array<string>;
        set dataList(val: Array<string>);
        mergeWith(prop: JsonObjectProperty): void;
        addDependedProperty(name: string): void;
        getDependedProperties(): Array<string>;
        schemaType(): string;
}
export declare class CustomPropertiesCollection {
        static addProperty(className: string, property: any): void;
        static removeProperty(className: string, propertyName: string): void;
        static addClass(className: string, parentClassName: string): void;
        static getProperties(className: string): Array<any>;
        static createProperties(obj: any): void;
}
export declare class JsonMetadataClass {
        name: string;
        creator: (json?: any) => any;
        parentName: string;
        static requiredSymbol: string;
        static typeSymbol: string;
        properties: Array<JsonObjectProperty>;
        constructor(name: string, properties: Array<any>, creator?: (json?: any) => any, parentName?: string);
        find(name: string): JsonObjectProperty;
        createProperty(propInfo: any): JsonObjectProperty;
}
/**
    * The metadata object. It contains object properties' runtime information and allows you to modify it.
    */
export declare class JsonMetadata {
        getObjPropertyValue(obj: any, name: string): any;
        setObjPropertyValue(obj: any, name: string, val: any): void;
        addClass(name: string, properties: Array<any>, creator?: (json?: any) => any, parentName?: string): JsonMetadataClass;
        removeClass(name: string): void;
        overrideClassCreatore(name: string, creator: () => any): void;
        overrideClassCreator(name: string, creator: () => any): void;
        getProperties(className: string): Array<JsonObjectProperty>;
        getPropertiesByObj(obj: any): Array<JsonObjectProperty>;
        getDynamicPropertiesByObj(obj: any, dynamicType?: string): Array<JsonObjectProperty>;
        hasOriginalProperty(obj: Base, propName: string): boolean;
        getOriginalProperty(obj: Base, propName: string): JsonObjectProperty;
        getProperty(className: string, propertyName: string): JsonObjectProperty;
        findProperty(className: string, propertyName: string): JsonObjectProperty;
        findProperties(className: string, propertyNames: Array<string>): Array<JsonObjectProperty>;
        getAllPropertiesByName(propertyName: string): Array<JsonObjectProperty>;
        getAllClasses(): Array<string>;
        createClass(name: string, json?: any): any;
        getChildrenClasses(name: string, canBeCreated?: boolean): Array<JsonMetadataClass>;
        getRequiredProperties(name: string): Array<string>;
        addProperties(className: string, propertiesInfos: Array<any>): void;
        addProperty(className: string, propertyInfo: any): JsonObjectProperty;
        removeProperty(className: string, propertyName: string): boolean;
        findClass(name: string): JsonMetadataClass;
        isDescendantOf(className: string, ancestorClassName: string): boolean;
        addAlterNativeClassName(name: string, alternativeName: string): void;
        generateSchema(className?: string): any;
}
export declare class JsonError {
        type: string;
        message: string;
        description: string;
        at: Number;
        constructor(type: string, message: string);
        getFullDescription(): string;
}
export declare class JsonUnknownPropertyError extends JsonError {
        propertyName: string;
        className: string;
        constructor(propertyName: string, className: string);
}
export declare class JsonMissingTypeErrorBase extends JsonError {
        baseClassName: string;
        type: string;
        message: string;
        constructor(baseClassName: string, type: string, message: string);
}
export declare class JsonMissingTypeError extends JsonMissingTypeErrorBase {
        propertyName: string;
        baseClassName: string;
        constructor(propertyName: string, baseClassName: string);
}
export declare class JsonIncorrectTypeError extends JsonMissingTypeErrorBase {
        propertyName: string;
        baseClassName: string;
        constructor(propertyName: string, baseClassName: string);
}
export declare class JsonRequiredPropertyError extends JsonError {
        propertyName: string;
        className: string;
        constructor(propertyName: string, className: string);
}
export declare class JsonObject {
        static get metaData(): JsonMetadata;
        errors: JsonError[];
        lightSerializing: boolean;
        toJsonObject(obj: any, storeDefaults?: boolean): any;
        toObject(jsonObj: any, obj: any): void;
        toObjectCore(jsonObj: any, obj: any): void;
        toJsonObjectCore(obj: any, property: JsonObjectProperty, storeDefaults?: boolean): any;
        valueToJson(obj: any, result: any, property: JsonObjectProperty, storeDefaults?: boolean): void;
        valueToObj(value: any, obj: any, property: JsonObjectProperty): void;
}
/**
    * An alias for the metadata object. It contains object properties' runtime information and allows you to modify it.
    * @see JsonMetadata
    */
export declare var Serializer: JsonMetadata;

export interface ISurveyData {
    getValue(name: string): any;
    setValue(name: string, newValue: any, locNotification: any, allowNotifyValueChanged?: boolean): any;
    getVariable(name: string): any;
    setVariable(name: string, newValue: any): void;
    getComment(name: string): string;
    setComment(name: string, newValue: string, locNotification: any): any;
    getAllValues(): any;
    getFilteredValues(): any;
    getFilteredProperties(): any;
}
export interface ITextProcessor {
    processText(text: string, returnDisplayValue: boolean): string;
    processTextEx(text: string, returnDisplayValue: boolean, doEncoding: boolean): any;
}
export interface ISurveyErrorOwner extends ILocalizableOwner {
    getErrorCustomText(text: string, error: SurveyError): string;
}
export interface ISurvey extends ITextProcessor, ISurveyErrorOwner {
    getSkeletonComponentName(element: ISurveyElement): string;
    currentPage: IPage;
    pages: Array<IPage>;
    getCss(): any;
    isPageStarted(page: IPage): boolean;
    getQuestionByName(name: string): IQuestion;
    pageVisibilityChanged(page: IPage, newValue: boolean): any;
    panelVisibilityChanged(panel: IPanel, newValue: boolean): any;
    questionVisibilityChanged(question: IQuestion, newValue: boolean): any;
    isEditingSurveyElement: boolean;
    isClearValueOnHidden: boolean;
    isClearValueOnHiddenContainer: boolean;
    questionsOrder: string;
    questionCreated(question: IQuestion): any;
    questionAdded(question: IQuestion, index: number, parentPanel: any, rootPanel: any): any;
    panelAdded(panel: IElement, index: number, parentPanel: any, rootPanel: any): any;
    questionRemoved(question: IQuestion): any;
    panelRemoved(panel: IElement): any;
    questionRenamed(question: IQuestion, oldName: string, oldValueName: string): any;
    validateQuestion(question: IQuestion): SurveyError;
    validatePanel(panel: IPanel): SurveyError;
    hasVisibleQuestionByValueName(valueName: string): boolean;
    questionCountByValueName(valueName: string): number;
    processHtml(html: string): string;
    getSurveyMarkdownHtml(element: Base, text: string, name: string): string;
    getRendererForString(element: Base, name: string): string;
    getRendererContextForString(element: Base, locStr: LocalizableString): any;
    getExpressionDisplayValue(question: IQuestion, value: any, displayValue: string): string;
    isDisplayMode: boolean;
    isDesignMode: boolean;
    areInvisibleElementsShowing: boolean;
    areEmptyElementsHidden: boolean;
    isLoadingFromJson: boolean;
    isUpdateValueTextOnTyping: boolean;
    autoGrowComment: boolean;
    state: string;
    isLazyRendering: boolean;
    cancelPreviewByPage(panel: IPanel): any;
    editText: string;
    cssNavigationEdit: string;
    requiredText: string;
    beforeSettingQuestionErrors(question: IQuestion, errors: Array<SurveyError>): void;
    beforeSettingPanelErrors(question: IPanel, errors: Array<SurveyError>): void;
    getSurveyErrorCustomText(obj: Base, text: string, error: SurveyError): string;
    getElementTitleTagName(element: Base, tagName: string): string;
    questionTitlePattern: string;
    getUpdatedQuestionTitle(question: IQuestion, title: string): string;
    getUpdatedQuestionNo(question: IQuestion, no: string): string;
    getUpdatedElementTitleActions(element: ISurveyElement, titleActions: Array<IAction>): Array<IAction>;
    getUpdatedMatrixRowActions(question: QuestionMatrixDropdownModelBase, row: MatrixDropdownRowModelBase, actions: Array<IAction>): Array<IAction>;
    questionStartIndex: string;
    questionTitleLocation: string;
    questionDescriptionLocation: string;
    questionErrorLocation: string;
    storeOthersAsComment: boolean;
    maxTextLength: number;
    maxOthersLength: number;
    clearValueOnDisableItems: boolean;
    uploadFiles(question: IQuestion, name: string, files: File[], uploadingCallback: (status: string, data: any) => any): any;
    downloadFile(name: string, content: string, callback: (status: string, data: any) => any): any;
    clearFiles(question: IQuestion, name: string, value: any, fileName: string, clearCallback: (status: string, data: any) => any): any;
    updateChoicesFromServer(question: IQuestion, choices: Array<any>, serverResult: any): Array<any>;
    loadedChoicesFromServer(question: IQuestion): void;
    updateQuestionCssClasses(question: IQuestion, cssClasses: any): any;
    updatePanelCssClasses(panel: IPanel, cssClasses: any): any;
    updatePageCssClasses(panel: IPanel, cssClasses: any): any;
    updateChoiceItemCss(question: IQuestion, options: any): any;
    afterRenderQuestion(question: IQuestion, htmlElement: HTMLElement): any;
    afterRenderQuestionInput(question: IQuestion, htmlElement: HTMLElement): any;
    afterRenderPanel(panel: IElement, htmlElement: HTMLElement): any;
    afterRenderPage(htmlElement: HTMLElement): any;
    getQuestionByValueNameFromArray(valueName: string, name: string, index: number): IQuestion;
    matrixRowAdded(question: IQuestion, row: any): any;
    matrixBeforeRowAdded(options: {
        question: IQuestion;
        canAddRow: boolean;
    }): any;
    matrixRowRemoved(question: IQuestion, rowIndex: number, row: any): any;
    matrixRowRemoving(question: IQuestion, rowIndex: number, row: any): boolean;
    matrixAllowRemoveRow(question: IQuestion, rowIndex: number, row: any): boolean;
    matrixCellCreating(question: IQuestion, options: any): any;
    matrixCellCreated(question: IQuestion, options: any): any;
    matrixAfterCellRender(question: IQuestion, options: any): any;
    matrixCellValueChanged(question: IQuestion, options: any): any;
    matrixCellValueChanging(question: IQuestion, options: any): any;
    isValidateOnValueChanging: boolean;
    matrixCellValidate(question: IQuestion, options: any): SurveyError;
    dynamicPanelAdded(question: IQuestion): any;
    dynamicPanelRemoved(question: IQuestion, panelIndex: number, panel: IPanel): any;
    dynamicPanelItemValueChanged(question: IQuestion, options: any): any;
    dragAndDropAllow(options: any): boolean;
    scrollElementToTop(element: ISurveyElement, question: IQuestion, page: IPage, id: string): any;
    runExpression(expression: string): any;
    elementContentVisibilityChanged(element: ISurveyElement): void;
}
export interface ISurveyImpl {
    getSurveyData(): ISurveyData;
    getSurvey(): ISurvey;
    getTextProcessor(): ITextProcessor;
}
export interface IConditionRunner {
    runCondition(values: HashTable<any>, properties: HashTable<any>): any;
}
export interface IShortcutText {
    shortcutText: string;
}
export interface ISurveyElement extends IShortcutText {
    name: string;
    isVisible: boolean;
    isReadOnly: boolean;
    isPage: boolean;
    isPanel: boolean;
    containsErrors: boolean;
    parent: IPanel;
    skeletonComponentName: string;
    setSurveyImpl(value: ISurveyImpl, isLight?: boolean): any;
    onSurveyLoad(): any;
    onFirstRendering(): any;
    getType(): string;
    setVisibleIndex(value: number): number;
    locStrsChanged(): any;
    delete(): any;
    toggleState(): void;
    stateChangedCallback(): void;
    getTitleToolbar(): AdaptiveActionContainer;
}
export interface IElement extends IConditionRunner, ISurveyElement {
    visible: boolean;
    renderWidth: string;
    width: string;
    minWidth?: string;
    maxWidth?: string;
    isExpanded: boolean;
    isCollapsed: boolean;
    rightIndent: number;
    startWithNewLine: boolean;
    registerFunctionOnPropertyValueChanged(name: string, func: any, key: string): void;
    unRegisterFunctionOnPropertyValueChanged(name: string, key: string): void;
    getPanel(): IPanel;
    getLayoutType(): string;
    isLayoutTypeSupported(layoutType: string): boolean;
    removeElement(el: IElement): boolean;
    onAnyValueChanged(name: string): any;
    updateCustomWidgets(): any;
    clearIncorrectValues(): any;
    clearErrors(): any;
    dispose(): void;
    needResponsiveWidth(): boolean;
}
export interface IQuestion extends IElement, ISurveyErrorOwner {
    hasTitle: boolean;
    isEmpty(): boolean;
    onSurveyValueChanged(newValue: any): any;
    updateValueFromSurvey(newValue: any): any;
    updateCommentFromSurvey(newValue: any): any;
    supportGoNextPageAutomatic(): boolean;
    clearUnusedValues(): any;
    getDisplayValue(keysAsText: boolean, value: any): any;
    getValueName(): string;
    clearValue(): any;
    clearValueIfInvisible(): any;
    isAnswerCorrect(): boolean;
    updateValueWithDefaults(): any;
    getQuestionFromArray(name: string, index: number): IQuestion;
    value: any;
    survey: any;
}
export interface IParentElement {
    addElement(element: IElement, index: number): any;
    removeElement(element: IElement): boolean;
    isReadOnly: boolean;
}
export interface IPanel extends ISurveyElement, IParentElement {
    getChildrenLayoutType(): string;
    getQuestionTitleLocation(): string;
    getQuestionStartIndex(): string;
    parent: IPanel;
    elementWidthChanged(el: IElement): any;
    indexOf(el: IElement): number;
    elements: Array<IElement>;
    ensureRowsVisibility(): void;
}
export interface IPage extends IPanel, IConditionRunner {
    isStarted: boolean;
}
export interface ITitleOwner {
    name: string;
    no: string;
    requiredText: string;
    isRequireTextOnStart: boolean;
    isRequireTextBeforeTitle: boolean;
    isRequireTextAfterTitle: boolean;
    locTitle: LocalizableString;
}
export interface IProgressInfo {
    questionCount: number;
    answeredQuestionCount: number;
    requiredQuestionCount: number;
    requiredAnsweredQuestionCount: number;
}
export interface IWrapperObject {
    getOriginalObj(): Base;
    getClassNameProperty(): string;
}
export interface IFindElement {
    element: Base;
    str: LocalizableString;
}

export declare class ExpressionRunnerBase {
    constructor(expression: string);
    get expression(): string;
    set expression(value: string);
    getVariables(): Array<string>;
    hasFunction(): boolean;
    get isAsync(): boolean;
    canRun(): boolean;
    protected runCore(values: HashTable<any>, properties?: HashTable<any>): any;
    protected doOnComplete(res: any): void;
}
export declare class ConditionRunner extends ExpressionRunnerBase {
    onRunComplete: (result: boolean) => void;
    run(values: HashTable<any>, properties?: HashTable<any>): boolean;
    protected doOnComplete(res: any): void;
}
export declare class ExpressionRunner extends ExpressionRunnerBase {
    onRunComplete: (result: any) => void;
    run(values: HashTable<any>, properties?: HashTable<any>): any;
    protected doOnComplete(res: any): void;
}

interface IActionBarItemProps {
    item: Action;
}
export declare class SurveyAction extends SurveyElementBase<IActionBarItemProps, any> {
    get item(): Action;
    protected getStateElement(): Base;
    renderElement(): JSX.Element;
}
export declare class SurveyActionBarItem extends SurveyElementBase<IActionBarItemProps, any> {
    get item(): Action;
    protected getStateElement(): Base;
    renderElement(): JSX.Element;
    renderText(): JSX.Element;
    renderButtonContent(): JSX.Element;
    renderInnerButton(): JSX.Element;
}
export {};

export declare class ListModel extends ActionContainer {
    onItemSelect: (item: Action) => void;
    allowSelection: boolean;
    needFilter: boolean;
    isExpanded: boolean;
    selectedItem: IAction;
    filteredText: string;
    static INDENT: number;
    static MINELEMENTCOUNT: number;
    constructor(items: Array<IAction>, onItemSelect: (item: Action) => void, allowSelection: boolean, selectedItem?: IAction, onFilteredTextChange?: (text: string) => void);
    protected onSet(): void;
    selectItem: (itemValue: Action) => void;
    isItemDisabled: (itemValue: Action) => boolean;
    isItemSelected: (itemValue: Action) => boolean;
    getItemClass: (itemValue: Action) => string;
    getItemIndent: (itemValue: any) => string;
    get filteredTextPlaceholder(): any;
    onKeyDown(event: KeyboardEvent): void;
    onPointerDown(event: PointerEvent, item: any): void;
    refresh(): void;
}

export declare class PopupModel<T = any> extends Base {
    contentComponentName: string;
    contentComponentData: T;
    verticalPosition: VerticalPosition;
    horizontalPosition: HorizontalPosition;
    showPointer: boolean;
    isModal: boolean;
    onCancel: () => void;
    onApply: () => boolean;
    onHide: () => void;
    onShow: () => void;
    cssClass: string;
    title: string;
    displayMode: "popup" | "overlay";
    constructor(contentComponentName: string, contentComponentData: T, verticalPosition?: VerticalPosition, horizontalPosition?: HorizontalPosition, showPointer?: boolean, isModal?: boolean, onCancel?: () => void, onApply?: () => boolean, onHide?: () => void, onShow?: () => void, cssClass?: string, title?: string);
    get isVisible(): boolean;
    set isVisible(value: boolean);
    toggleVisibility(): void;
    onVisibilityChanged: (isVisible: boolean) => void;
}
export declare function createPopupModalViewModel(componentName: string, data: any, onApply: () => boolean, onCancel?: () => void, onHide?: () => void, onShow?: () => void, cssClass?: string, title?: string, displayMode?: "popup" | "overlay"): PopupBaseViewModel;
export declare class PopupBaseViewModel extends Base {
    targetElement?: HTMLElement;
    top: string;
    left: string;
    height: string;
    isVisible: boolean;
    popupDirection: string;
    pointerTarget: IPosition;
    container: HTMLElement;
    get model(): PopupModel;
    set model(model: PopupModel);
    constructor(model: PopupModel, targetElement?: HTMLElement);
    get title(): string;
    get contentComponentName(): string;
    get contentComponentData(): any;
    get showPointer(): boolean;
    get isModal(): boolean;
    get showFooter(): boolean;
    get isOverlay(): boolean;
    get styleClass(): string;
    onKeyDown(event: any): void;
    updateOnShowing(): void;
    updateOnHiding(): void;
    clickOutside(): void;
    cancel(): void;
    apply(): void;
    get cancelButtonText(): any;
    get applyButtonText(): any;
    dispose(): void;
    createPopupContainer(): void;
    mountPopupContainer(): void;
    initializePopupContainer(): void;
    destroyPopupContainer(): void;
}

/**
    * Defines an individual action. Action items can be displayed in certain survey elements - in Toolbar (or action bar), in titles (of pages, panels, questions), in matrix rows (as 'expand details' or 'remove row' buttons), and etc.
    */
export interface IAction {
        /**
            * Unique string id
            */
        id: string;
        /**
            * Set this property to false to make the toolbar item invisible.
            */
        visible?: boolean;
        /**
            * Toolbar item title
            */
        title?: string;
        /**
            * Toolbar item tooltip
            */
        tooltip?: string;
        /**
            * Set this property to false to disable the toolbar item.
            */
        enabled?: boolean;
        /**
            * Set this property to false to hide the toolbar item title.
            */
        showTitle?: boolean;
        /**
            * A callback that calls on toolbar item click.
            */
        action?: (context?: any) => void;
        /**
            * Toolbar item css class
            */
        css?: string;
        /**
            * Toolbar inner element css class
            */
        innerCss?: string;
        /**
            * Toolbar item data object. Used as data for custom template or component rendering
            */
        data?: any;
        popupModel?: any;
        needSeparator?: boolean;
        /**
            * Set this property to true to activate the toolbar item (page)
            */
        active?: boolean;
        pressed?: boolean;
        /**
            * Toolbar item template name
            */
        template?: string;
        /**
            * Toolbar item component name
            */
        component?: string;
        /**
            * Toolbar item icon name
            */
        iconName?: string;
        /**
            * Toolbar item icon size
            */
        iconSize?: number;
        /**
            * Toolbar item child items. Can be used as contianer for options
            */
        items?: any;
        /**
            * Gets or sets an action's location in a matrix question's row.
            *
            * The following options are available:
            *
            * - `start` - An action is located at the beginning of a row.
            * - `end` - An action is located at the end of a row.
            */
        location?: string;
        /**
            * Set it to true to make the tabIndex -1 to disable keyboard navigation to this item
            */
        disableTabStop?: boolean;
        /**
            * Set it to false to force action "large" mode even if has icon and does not fit to action bar space
            */
        disableShrink?: boolean;
        /**
            * Action button display mode
            */
        mode?: "large" | "small" | "popup";
        visibleIndex?: number;
}
export declare class Action extends Base implements IAction {
        innerItem: IAction;
        updateCallback: () => void;
        constructor(innerItem: IAction);
        location?: string;
        id: string;
        iconName: string;
        iconSize: number;
        visible: boolean;
        title: string;
        tooltip: string;
        enabled: boolean;
        showTitle: boolean;
        action: (context?: any) => void;
        css: string;
        innerCss: string;
        data: any;
        popupModel: any;
        needSeparator: boolean;
        active: boolean;
        pressed: boolean;
        template: string;
        component: string;
        items: any;
        visibleIndex: number;
        mode: "large" | "small" | "popup";
        disableTabStop: boolean;
        disableShrink: boolean;
        get disabled(): boolean;
        get hasTitle(): boolean;
        get isVisible(): boolean;
        get canShrink(): boolean;
        getActionRootCss(): string;
        getActionBarItemCss(): string;
        getActionBarItemActiveCss(): string;
        minDimension: number;
        maxDimension: number;
}

export declare class ActionContainer<T extends Action = Action> extends Base {
    actions: Array<T>;
    protected getRenderedActions(): Array<T>;
    updateCallback: (isResetInitialized: boolean) => void;
    containerCss: string;
    protected raiseUpdate(isResetInitialized: boolean): void;
    protected onSet(): void;
    protected onPush(item: T): void;
    protected onRemove(item: T): void;
    get hasActions(): boolean;
    get renderedActions(): Array<T>;
    get visibleActions(): Array<T>;
    get css(): string;
    setItems(items: Array<IAction>, sortByVisibleIndex?: boolean): void;
    initResponsivityManager(container: HTMLDivElement): void;
    resetResponsivityManager(): void;
}

export declare class SurveyError {
    text: string;
    protected errorOwner: ISurveyErrorOwner;
    visible: boolean;
    constructor(text?: string, errorOwner?: ISurveyErrorOwner);
    get locText(): LocalizableString;
    getText(): string;
    getErrorType(): string;
    protected getDefaultText(): string;
}

export interface IConditionObject {
        name: string;
        text: string;
        question: Question;
}
/**
    * A base class for all questions.
    */
export declare class Question extends SurveyElement implements IQuestion, IConditionRunner, IValidatorOwner, ITitleOwner {
        [index: string]: any;
        customWidgetData: {
                isNeedRender: boolean;
        };
        focusCallback: () => void;
        surveyLoadCallback: () => void;
        displayValueCallback: (text: string) => string;
        valueChangedCallback: () => void;
        commentChangedCallback: () => void;
        validateValueCallback: () => SurveyError;
        questionTitleTemplateCallback: () => string;
        afterRenderQuestionCallback: (question: Question, element: any) => any;
        valueFromDataCallback: (val: any) => any;
        valueToDataCallback: (val: any) => any;
        onGetSurvey: () => ISurvey;
        protected isReadyValue: boolean;
        /**
            * The event is fired when isReady property of question is changed.
            * <br/> options.question - the question
            * <br/> options.isReady - current value of isReady
            * <br/> options.oldIsReady - old value of isReady
            */
        onReadyChanged: EventBase<Question>;
        isReadOnlyRenderDiv(): boolean;
        constructor(name: string);
        protected createLocTitleProperty(): LocalizableString;
        getSurvey(live?: boolean): ISurvey;
        getValueName(): string;
        /**
            * Use this property if you want to store the question result in the name different from the question name.
            * Question name should be unique in the survey and valueName could be not unique. It allows to share data between several questions with the same valueName.
            * The library set the value automatically if the question.name property is not valid. For example, if it contains the period '.' symbol.
            * In this case if you set the question.name property to 'x.y' then the valueName becomes 'x y'.
            * Please note, this property is hidden for questions without input, for example html question.
            * @see name
            */
        get valueName(): string;
        set valueName(val: string);
        protected onValueNameChanged(oldValue: string): void;
        protected onNameChanged(oldValue: string): void;
        get isReady(): boolean;
        /**
            * A11Y properties
            */
        get ariaRequired(): "true" | "false";
        get ariaLabel(): string;
        get ariaInvalid(): "true" | "false";
        get ariaDescribedBy(): string;
        /**
            * Get is question ready to use
            */
        choicesLoaded(): void;
        /**
            * Get/set the page where the question is located.
            */
        get page(): IPage;
        set page(val: IPage);
        getPanel(): IPanel;
        delete(): void;
        get isFlowLayout(): boolean;
        getLayoutType(): string;
        isLayoutTypeSupported(layoutType: string): boolean;
        /**
            * Use it to get/set the question visibility.
            * @see visibleIf
            */
        get visible(): boolean;
        set visible(val: boolean);
        protected onVisibleChanged(): void;
        /**
            * Use it to choose how other question values will be rendered in title if referenced in {}.
            * Please note, this property is hidden for question without input, for example html question.
            */
        get useDisplayValuesInTitle(): boolean;
        set useDisplayValuesInTitle(val: boolean);
        protected getUseDisplayValuesInTitle(): boolean;
        /**
            * An expression that returns true or false. If it returns true the Question becomes visible and if it returns false the Question becomes invisible. The library runs the expression on survey start and on changing a question value. If the property is empty then visible property is used.
            * @see visible
            */
        get visibleIf(): string;
        set visibleIf(val: string);
        /**
            * Returns true if the question is visible or survey is in design mode right now.
            */
        get isVisible(): boolean;
        /**
            * Returns the visible index of the question in the survey. It can be from 0 to all visible questions count - 1
            * The visibleIndex is -1 if the title is 'hidden' or hideNumber is true
            * @see titleLocation
            * @see hideNumber
            */
        get visibleIndex(): number;
        /**
            * Set hideNumber to true to stop showing the number for this question. The question will not be counter
            * @see visibleIndex
            * @see titleLocation
            */
        get hideNumber(): boolean;
        set hideNumber(val: boolean);
        /**
            * Returns true if the question may have a title located on the left
            */
        get isAllowTitleLeft(): boolean;
        /**
            * Returns the type of the object as a string as it represents in the json.
            */
        getType(): string;
        get isQuestion(): boolean;
        /**
            * Move question to a new container Page/Panel. Add as a last element if insertBefore parameter is not used or inserted into the given index,
            * if insert parameter is number, or before the given element, if the insertBefore parameter is a question or panel
            * @param container Page or Panel to where a question is relocated.
            * @param insertBefore Use it if you want to set the question to a specific position. You may use a number (use 0 to insert int the beginning) or element, if you want to insert before this element.
            */
        moveTo(container: IPanel, insertBefore?: any): boolean;
        getProgressInfo(): IProgressInfo;
        setSurveyImpl(value: ISurveyImpl, isLight?: boolean): void;
        getDataFilteredValues(): any;
        getDataFilteredProperties(): any;
        /**
            * A parent element. It can be panel or page.
            */
        get parent(): IPanel;
        set parent(val: IPanel);
        /**
            * A parent question. It can be a dynamic panel or dynamic/dropdown matrices. If the value is a matrix, it means that question is a cell question.
            * This property is null for a stand alone question.
            */
        get parentQuestion(): Question;
        setParentQuestion(val: Question): void;
        protected onParentQuestionChanged(): void;
        protected onParentChanged(): void;
        /**
            * Returns false if the question doesn't have a title property, for example: QuestionHtmlModel, or titleLocation property equals to "hidden"
            * @see titleLocation
            */
        get hasTitle(): boolean;
        /**
            * Set this property different from "default" to set the specific question title location for this panel/page.
            * Please note, this property is hidden for questions without input, for example html question.
            * @see SurveyModel.questionTitleLocation
            */
        get titleLocation(): string;
        set titleLocation(value: string);
        getTitleOwner(): ITitleOwner;
        /**
            * Return the title location based on question titleLocation property and QuestionTitleLocation of it's parents
            * @see titleLocation
            * @see PanelModelBase.QuestionTitleLocation
            * @see SurveyModel.QuestionTitleLocation
            */
        getTitleLocation(): string;
        protected getTitleLocationCore(): string;
        get hasTitleOnLeft(): boolean;
        get hasTitleOnTop(): boolean;
        get hasTitleOnBottom(): boolean;
        get hasTitleOnLeftTop(): boolean;
        get errorLocation(): string;
        /**
            * Returns false if the question doesn't have an input element, for example: QuestionHtmlModel
            * @see hasSingleInput
            */
        get hasInput(): boolean;
        /**
            * Returns false if the question doesn't have an input element or have multiple inputs: matrices or panel dynamic
            * @see hasInput
            */
        get hasSingleInput(): boolean;
        get inputId(): string;
        protected getDefaultTitleValue(): string;
        protected getDefaultTitleTagName(): string;
        /**
            * Question description location. By default, value is "default" and it depends on survey questionDescriptionLocation property
            * You may change it to "underInput" to render it under question input or "underTitle" to rendered it under title.
            * @see description
            * @see Survey.questionDescriptionLocation
            */
        get descriptionLocation(): string;
        set descriptionLocation(val: string);
        get hasDescriptionUnderTitle(): boolean;
        get hasDescriptionUnderInput(): boolean;
        get clickTitleFunction(): any;
        /**
            * The custom text that will be shown on required error. Use this property, if you do not want to show the default text.
            * Please note, this property is hidden for question without input, for example html question.
            */
        get requiredErrorText(): string;
        set requiredErrorText(val: string);
        get locRequiredErrorText(): LocalizableString;
        /**
            * Use it to get or set the comment value.
            */
        get commentText(): string;
        set commentText(val: string);
        get locCommentText(): LocalizableString;
        /**
            * Returns a copy of question errors survey. For some questions like matrix and panel dynamic it includes the errors of nested questions.
            */
        getAllErrors(): Array<SurveyError>;
        getErrorByType(errorType: string): SurveyError;
        /**
            * The link to the custom widget.
            */
        get customWidget(): QuestionCustomWidget;
        updateCustomWidget(): void;
        get isCompositeQuestion(): boolean;
        updateCommentElement(): void;
        onCommentInput(event: any): void;
        onCommentChange(event: any): void;
        afterRenderQuestionElement(el: HTMLElement): void;
        afterRender(el: HTMLElement): void;
        beforeDestroyQuestionElement(el: HTMLElement): void;
        /**
            * Returns the rendred question title.
            */
        get processedTitle(): string;
        /**
            * Returns the title after processing the question template.
            * @see SurveyModel.questionTitleTemplate
            */
        get fullTitle(): string;
        protected get titlePattern(): string;
        get isRequireTextOnStart(): boolean;
        get isRequireTextBeforeTitle(): boolean;
        get isRequireTextAfterTitle(): boolean;
        /**
            * The Question renders on the new line if the property is true. If the property is false, the question tries to render on the same line/row with a previous question/panel.
            */
        get startWithNewLine(): boolean;
        set startWithNewLine(val: boolean);
        protected calcCssClasses(css: any): any;
        get cssRoot(): string;
        protected setCssRoot(val: string): void;
        protected getCssRoot(cssClasses: any): string;
        get cssHeader(): string;
        protected setCssHeader(val: string): void;
        protected getCssHeader(cssClasses: any): string;
        get cssContent(): string;
        protected setCssContent(val: string): void;
        protected getCssContent(cssClasses: any): string;
        get cssTitle(): string;
        protected setCssTitle(val: string): void;
        protected getCssTitle(cssClasses: any): string;
        get cssError(): string;
        protected setCssError(val: string): void;
        protected getCssError(cssClasses: any): string;
        getRootCss(): string;
        updateElementCss(reNew?: boolean): void;
        protected updateQuestionCss(reNew?: boolean): void;
        protected updateElementCssCore(cssClasses: any): void;
        protected updateCssClasses(res: any, css: any): void;
        protected getCssType(): string;
        /**
            * Use it to set the specific width to the question like css style (%, px, em etc).
            */
        get width(): string;
        set width(val: string);
        /**
            * Use it to set the specific minWidth constraint to the question like css style (%, px, em etc).
            */
        get minWidth(): string;
        set minWidth(val: string);
        /**
            * Use it to set the specific maxWidth constraint to the question like css style (%, px, em etc).
            */
        get maxWidth(): string;
        set maxWidth(val: string);
        /**
            * The rendered width of the question.
            */
        get renderWidth(): string;
        set renderWidth(val: string);
        get renderCssRoot(): string;
        /**
            * Set it different from 0 to increase the left padding.
            */
        get indent(): number;
        set indent(val: number);
        /**
            * Set it different from 0 to increase the right padding.
            */
        get rightIndent(): number;
        set rightIndent(val: number);
        get paddingLeft(): string;
        set paddingLeft(val: string);
        get paddingRight(): string;
        set paddingRight(val: string);
        /**
            * Move the focus to the input of this question.
            * @param onError set this parameter to true, to focus the input with the first error, other wise the first input will be focused.
            */
        focus(onError?: boolean): void;
        focusIn: () => void;
        protected fireCallback(callback: () => void): void;
        getOthersMaxLength(): any;
        protected onCreating(): void;
        protected getFirstInputElementId(): string;
        protected getFirstErrorInputElementId(): string;
        protected getProcessedTextValue(textValue: TextPreProcessorValue): void;
        supportComment(): boolean;
        supportOther(): boolean;
        /**
            * Set this property to true, to make the question a required. If a user doesn't answer the question then a validation error will be generated.
            * Please note, this property is hidden for question without input, for example html question.
            */
        get isRequired(): boolean;
        set isRequired(val: boolean);
        /**
            * An expression that returns true or false. If it returns true the Question becomes required and an end-user has to answer it.
            * If it returns false the Question then an end-user may not answer it the Question maybe empty.
            * The library runs the expression on survey start and on changing a question value. If the property is empty then isRequired property is used.
            * Please note, this property is hidden for question without input, for example html question.
            * @see isRequired
            */
        get requiredIf(): string;
        set requiredIf(val: string);
        /**
            * Set it to true, to add a comment for the question.
            */
        get hasComment(): boolean;
        set hasComment(val: boolean);
        /**
            * The unique identificator. It is generated automatically.
            */
        get id(): string;
        set id(val: string);
        get ariaTitleId(): string;
        get ariaRole(): string;
        get hasOther(): boolean;
        set hasOther(val: boolean);
        protected hasOtherChanged(): void;
        get requireUpdateCommentValue(): boolean;
        /**
            * Returns true if readOnly property is true or survey is in display mode or parent panel/page is readOnly.
            * @see SurveyModel.model
            * @see readOnly
            */
        get isReadOnly(): boolean;
        get isInputReadOnly(): boolean;
        get renderedInputReadOnly(): string;
        get renderedInputDisabled(): string;
        protected onReadOnlyChanged(): void;
        /**
            * An expression that returns true or false. If it returns false the Question becomes read only and an end-user will not able to answer on the qustion. The library runs the expression on survey start and on changing a question value. If the property is empty then readOnly property is used.
            * Please note, this property is hidden for question without input, for example html question.
            * @see readOnly
            * @see isReadOnly
            */
        get enableIf(): string;
        set enableIf(val: string);
        /**
            * Run visibleIf and enableIf expressions. If visibleIf or/and enabledIf are not empty, then the results of performing the expression (true or false) set to the visible/readOnly properties.
            * @param values Typically survey results
            * @see visible
            * @see visibleIf
            * @see readOnly
            * @see enableIf
            */
        runCondition(values: HashTable<any>, properties: HashTable<any>): void;
        /**
            * The property returns the question number. If question is invisible then it returns empty string.
            * If visibleIndex is 1, then no is 2, or 'B' if survey.questionStartIndex is 'A'.
            * @see SurveyModel.questionStartIndex
            */
        get no(): string;
        protected getStartIndex(): string;
        onSurveyLoad(): void;
        protected onSetData(): void;
        protected initDataFromSurvey(): void;
        protected initCommentFromSurvey(): void;
        protected runExpression(expression: string): any;
        /**
            * Get/Set the question value.
            * @see SurveyMode.setValue
            * @see SurveyMode.getValue
            */
        get value(): any;
        set value(newValue: any);
        get valueForSurvey(): any;
        /**
            * Clear the question value. It clears the question comment as well.
            */
        clearValue(): void;
        unbindValue(): void;
        createValueCopy(): any;
        protected getUnbindValue(value: any): any;
        protected isValueSurveyElement(val: any): boolean;
        /**
            * Return true if there is a parent (page or panel) and it is visible
            */
        get isParentVisible(): boolean;
        clearValueIfInvisible(): void;
        get displayValue(): any;
        /**
            * Return the question value as a display text. For example, for dropdown, it would return the item text instead of item value.
            * @param keysAsText Set this value to true, to return key (in matrices questions) as display text as well.
            * @param value use this parameter, if you want to get display value for this value and not question.value. It is undefined by default.
            */
        getDisplayValue(keysAsText: boolean, value?: any): any;
        protected getDisplayValueCore(keyAsText: boolean, value: any): any;
        protected getDisplayValueEmpty(): string;
        /**
            * Set the default value to the question. It will be assign to the question on loading the survey from JSON or adding a question to the survey or on setting this property of the value is empty.
            * Please note, this property is hidden for question without input, for example html question.
            */
        get defaultValue(): any;
        set defaultValue(val: any);
        get defaultValueExpression(): any;
        set defaultValueExpression(val: any);
        get resizeStyle(): "none" | "both";
        /**
            * Returns question answer data as a plain object: with question title, name, value and displayValue.
            * For complex questions (like matrix, etc.) isNode flag is set to true and data contains array of nested objects (rows)
            * set options.includeEmpty to false if you want to skip empty answers
            */
        getPlainData(options?: {
                includeEmpty?: boolean;
                includeQuestionTypes?: boolean;
                calculations?: Array<{
                        propertyName: string;
                }>;
        }): any;
        /**
            * The correct answer on the question. Set this value if you are doing a quiz.
            * Please note, this property is hidden for question without input, for example html question.
            * @see SurveyModel.correctAnswers
            * @see SurveyModel.inCorrectAnswers
            */
        get correctAnswer(): any;
        set correctAnswer(val: any);
        protected convertDefaultValue(val: any): any;
        /**
            * Returns questions count: 1 for the non-matrix questions and all inner visible questions that has input(s) widgets for question of matrix types.
            * @see getQuizQuestions
            */
        get quizQuestionCount(): number;
        get correctAnswerCount(): number;
        protected getQuizQuestionCount(): number;
        protected getCorrectAnswerCount(): number;
        isAnswerCorrect(): boolean;
        updateValueWithDefaults(): void;
        getQuestionFromArray(name: string, index: number): IQuestion;
        getDefaultValue(): any;
        protected isDefaultValueEmpty(): boolean;
        protected setDefaultValue(): void;
        protected isValueExpression(val: any): boolean;
        protected setValueAndRunExpression(expression: string, defaultValue: any, setFunc: (val: any) => void, values?: HashTable<any>, properties?: HashTable<any>): void;
        /**
            * The question comment value.
            */
        get comment(): string;
        set comment(newValue: string);
        protected getQuestionComment(): string;
        protected setQuestionComment(newValue: string): void;
        /**
            * Returns true if the question value is empty
            */
        isEmpty(): boolean;
        get isAnswered(): boolean;
        set isAnswered(val: boolean);
        protected updateIsAnswered(): void;
        protected getIsAnswered(): boolean;
        /**
            * The list of question validators.
            * Please note, this property is hidden for question without input, for example html question.
            */
        get validators(): Array<SurveyValidator>;
        set validators(val: Array<SurveyValidator>);
        getValidators(): Array<SurveyValidator>;
        getSupportedValidators(): Array<string>;
        addConditionObjectsByContext(objects: Array<IConditionObject>, context: any): void;
        getConditionJson(operator?: string, path?: string): any;
        /**
            * Returns true if there is a validation error(s) in the question.
            * @param fireCallback set it to true to show an error in UI.
            */
        hasErrors(fireCallback?: boolean, rec?: any): boolean;
        /**
            * Returns the validation errors count.
            */
        get currentErrorCount(): number;
        /**
            * Returns the char/string for a required question.
            * @see SurveyModel.requiredText
            */
        get requiredText(): string;
        /**
            * Add error into the question error list.
            * @param error
            */
        addError(error: SurveyError | string): void;
        /**
            * Remove a particular error from the question error list.
            * @param error
            */
        removeError(error: SurveyError): void;
        protected canCollectErrors(): boolean;
        protected canRunValidators(isOnValueChanged: boolean): boolean;
        protected onCheckForErrors(errors: Array<SurveyError>, isOnValueChanged: boolean): void;
        protected hasRequiredError(): boolean;
        onCompletedAsyncValidators: (hasErrors: boolean) => void;
        get isRunningValidators(): boolean;
        protected getIsRunningValidators(): boolean;
        protected runValidators(): Array<SurveyError>;
        protected raiseOnCompletedAsyncValidators(): void;
        protected allowNotifyValueChanged: boolean;
        protected setNewValue(newValue: any): void;
        protected isTextValue(): boolean;
        get isSurveyInputTextUpdate(): boolean;
        get isInputTextUpdate(): boolean;
        protected setNewValueInData(newValue: any): void;
        protected getValueCore(): any;
        protected setValueCore(newValue: any): void;
        protected canSetValueToSurvey(): boolean;
        protected valueFromData(val: any): any;
        protected valueToData(val: any): any;
        protected onValueChanged(): void;
        protected setNewComment(newValue: string): void;
        protected getValidName(name: string): string;
        updateValueFromSurvey(newValue: any): void;
        updateCommentFromSurvey(newValue: any): any;
        protected setQuestionValue(newValue: any, updateIsAnswered?: boolean): void;
        onSurveyValueChanged(newValue: any): void;
        setVisibleIndex(val: number): number;
        removeElement(element: IElement): boolean;
        supportGoNextPageAutomatic(): boolean;
        supportGoNextPageError(): boolean;
        /**
            * Call this function to remove values from the current question, that end-user will not be able to enter.
            * For example the value that doesn't exists in a radigroup/dropdown/checkbox choices or matrix rows/columns.
            */
        clearIncorrectValues(): void;
        clearOnDeletingContainer(): void;
        /**
            * Call this function to clear all errors in the question
            */
        clearErrors(): void;
        clearUnusedValues(): void;
        onAnyValueChanged(name: string): void;
        checkBindings(valueName: string, value: any): void;
        getComponentName(): string;
        isDefaultRendering(): boolean;
        renderAs: string;
        getErrorCustomText(text: string, error: SurveyError): string;
        getValidatorTitle(): string;
        get validatedValue(): any;
        set validatedValue(val: any);
        getAllValues(): any;
        needResponsiveWidth(): boolean;
}

/**
    * A definition for filling choices for checkbox, dropdown and radiogroup questions from resfull services.
    * The run method call a restful service and results can be get on getResultCallback.
    */
export declare class ChoicesRestful extends Base {
        static get EncodeParameters(): boolean;
        static set EncodeParameters(val: boolean);
        static clearCache(): void;
        static onBeforeSendRequest: (sender: ChoicesRestful, options: {
                request: XMLHttpRequest;
        }) => void;
        protected processedUrl: string;
        protected processedPath: string;
        onProcessedUrlCallback: (url: string, path: string) => void;
        getResultCallback: (items: Array<ItemValue>) => void;
        beforeSendRequestCallback: () => void;
        updateResultCallback: (items: Array<ItemValue>, serverResult: any) => Array<ItemValue>;
        getItemValueCallback: (item: any) => any;
        error: SurveyError;
        owner: IQuestion;
        createItemValue: (value: any) => ItemValue;
        constructor();
        getSurvey(live?: boolean): ISurvey;
        run(textProcessor?: ITextProcessor): void;
        get isUsingCache(): boolean;
        get isRunning(): boolean;
        protected getIsRunning(): boolean;
        get isWaitingForParameters(): boolean;
        protected useChangedItemsResults(): boolean;
        protected parseResponse(response: any): any;
        protected sendRequest(): void;
        getType(): string;
        get isEmpty(): boolean;
        getCustomPropertiesNames(): Array<string>;
        setData(json: any): void;
        getData(): any;
        /**
            * Gets or sets a link to a web service. You can use text preprocessing here.
            * For example, the following url: _https://surveyjs.io/api/CountriesExample?region={region}_ is changed based on the _region_ question's value.
            * SurveyJS automatically gets data from the web service when the value of the _region_ question changes.
            * @see path
            * @see valueName
            * @see titleName
            * @see [Example: RESTful Dropdown](https://surveyjs.io/Examples/Library/?id=questiontype-dropdownrestfull)
            * @see [Docs: Fill Choices from a RESTful Service](https://surveyjs.io/Documentation/Library/?id=LibraryOverview#fill-the-choices-from-a-restful-service)
            */
        get url(): string;
        set url(val: string);
        /**
            * Use this property, if a web service returns a lot of information and you need only a part of it.
            * For example, a web service returns a list of countries and a list of capitals.
            * If you need a list of countries, set a correct path from which SurveyJS obtains the data, like: _DataList1\DataList2_
            * @see url
            * @see valueName
            * @see titleName
            * @see [Example: RESTful Dropdown](https://surveyjs.io/Examples/Library/?id=questiontype-dropdownrestfull)
            * @see [Docs: Fill Choices from a RESTful Service](https://surveyjs.io/Documentation/Library/?id=LibraryOverview#fill-the-choices-from-a-restful-service)
            */
        get path(): string;
        set path(val: string);
        /**
            * Gets or sets the name of a property (in the obtained data object) to which SurveyJS binds to provide values for choice items.
            * @see url
            * @see path
            * @see titleName
            * @see [Example: RESTful Dropdown](https://surveyjs.io/Examples/Library/?id=questiontype-dropdownrestfull)
            * @see [Docs: Fill Choices from a RESTful Service](https://surveyjs.io/Documentation/Library/?id=LibraryOverview#fill-the-choices-from-a-restful-service)
            */
        get valueName(): string;
        set valueName(val: string);
        /**
            * Gets or sets the name of a property (in the obtained data object) to which SurveyJS binds to provide display texts for choice items.
            * @see url
            * @see path
            * @see valueeName
            * @see [Example: RESTful Dropdown](https://surveyjs.io/Examples/Library/?id=questiontype-dropdownrestfull)
            * @see [Docs: Fill Choices from a RESTful Service](https://surveyjs.io/Documentation/Library/?id=LibraryOverview#fill-the-choices-from-a-restful-service)
            */
        get titleName(): string;
        set titleName(val: string);
        get imageLinkName(): string;
        set imageLinkName(val: string);
        get allowEmptyResponse(): boolean;
        set allowEmptyResponse(val: boolean);
        get attachOriginalItems(): boolean;
        set attachOriginalItems(val: boolean);
        get itemValueType(): string;
        clear(): void;
        protected beforeSendRequest(): void;
        protected beforeLoadRequest(): void;
        protected onLoad(result: any, loadingObjHash?: string): void;
        protected callResultCallback(items: Array<ItemValue>, loadingObjHash: string): void;
}
/**
    * Obsolete, please use ChoicesRestful
    */
export declare class ChoicesRestfull extends ChoicesRestful {
        static get EncodeParameters(): boolean;
        static set EncodeParameters(val: boolean);
        static clearCache(): void;
        static get onBeforeSendRequest(): (sender: ChoicesRestful, options: {
                request: XMLHttpRequest;
        }) => void;
        static set onBeforeSendRequest(val: (sender: ChoicesRestful, options: {
                request: XMLHttpRequest;
        }) => void);
}

export interface HashTable<T> {
    [key: string]: T;
}
export declare class Helpers {
    /**
      * A static methods that returns true if a value undefined, null, empty string or empty array.
      * @param value
      */
    static isValueEmpty(value: any): boolean;
    static isArrayContainsEqual(x: any, y: any): boolean;
    static isArraysEqual(x: any, y: any, ignoreOrder?: boolean, caseSensitive?: boolean, trimStrings?: boolean): boolean;
    static isTwoValueEquals(x: any, y: any, ignoreOrder?: boolean, caseSensitive?: boolean, trimStrings?: boolean): boolean;
    static randomizeArray<T>(array: Array<T>): Array<T>;
    static getUnbindValue(value: any): any;
    static createCopy(obj: any): any;
    static isConvertibleToNumber(value: any): boolean;
    static isNumber(value: any): boolean;
    static getMaxLength(maxLength: number, surveyLength: number): any;
    static getNumberByIndex(index: number, startIndexStr: string): string;
    static isCharNotLetterAndDigit(ch: string): boolean;
    static isCharDigit(ch: string): boolean;
    static correctAfterPlusMinis(a: number, b: number, res: number): number;
    static correctAfterMultiple(a: number, b: number, res: number): number;
}

export interface IMatrixDropdownData {
        value: any;
        onRowChanged(row: MatrixDropdownRowModelBase, columnName: string, newRowValue: any, isDeletingValue: boolean): void;
        onRowChanging(row: MatrixDropdownRowModelBase, columnName: string, rowValue: any): any;
        isValidateOnValueChanging: boolean;
        getRowIndex(row: MatrixDropdownRowModelBase): number;
        getRowValue(rowIndex: number): any;
        checkIfValueInRowDuplicated(checkedRow: MatrixDropdownRowModelBase, cellQuestion: Question): boolean;
        hasDetailPanel(row: MatrixDropdownRowModelBase): boolean;
        getIsDetailPanelShowing(row: MatrixDropdownRowModelBase): boolean;
        setIsDetailPanelShowing(row: MatrixDropdownRowModelBase, val: boolean): void;
        createRowDetailPanel(row: MatrixDropdownRowModelBase): PanelModel;
        validateCell(row: MatrixDropdownRowModelBase, columnName: string, rowValue: any): SurveyError;
        columns: Array<MatrixDropdownColumn>;
        createQuestion(row: MatrixDropdownRowModelBase, column: MatrixDropdownColumn): Question;
        getLocale(): string;
        getMarkdownHtml(text: string, name: string): string;
        getRenderer(name: string): string;
        getRendererContext(locStr: LocalizableString): any;
        getProcessedText(text: string): string;
        getParentTextProcessor(): ITextProcessor;
        getSharedQuestionByName(columnName: string, row: MatrixDropdownRowModelBase): Question;
        onTotalValueChanged(): any;
        getSurvey(): ISurvey;
}
export declare class MatrixDropdownCell {
        column: MatrixDropdownColumn;
        row: MatrixDropdownRowModelBase;
        data: IMatrixDropdownData;
        constructor(column: MatrixDropdownColumn, row: MatrixDropdownRowModelBase, data: IMatrixDropdownData);
        locStrsChanged(): void;
        protected createQuestion(column: MatrixDropdownColumn, row: MatrixDropdownRowModelBase, data: IMatrixDropdownData): Question;
        get question(): Question;
        get value(): any;
        set value(value: any);
        runCondition(values: HashTable<any>, properties: HashTable<any>): void;
}
export declare class MatrixDropdownTotalCell extends MatrixDropdownCell {
        column: MatrixDropdownColumn;
        row: MatrixDropdownRowModelBase;
        data: IMatrixDropdownData;
        constructor(column: MatrixDropdownColumn, row: MatrixDropdownRowModelBase, data: IMatrixDropdownData);
        protected createQuestion(column: MatrixDropdownColumn, row: MatrixDropdownRowModelBase, data: IMatrixDropdownData): Question;
        locStrsChanged(): void;
        updateCellQuestion(): void;
        getTotalExpression(): string;
}
export declare class MatrixDropdownRowModelBase implements ISurveyData, ISurveyImpl, ILocalizableOwner {
        static RowVariableName: string;
        static OwnerVariableName: string;
        static IndexVariableName: string;
        static RowValueVariableName: string;
        protected data: IMatrixDropdownData;
        protected isSettingValue: boolean;
        cells: Array<MatrixDropdownCell>;
        showHideDetailPanelClick: any;
        onDetailPanelShowingChanged: () => void;
        constructor(data: IMatrixDropdownData, value: any);
        get id(): string;
        get rowName(): any;
        get text(): any;
        get value(): any;
        set value(value: any);
        get locText(): LocalizableString;
        get hasPanel(): boolean;
        get detailPanel(): PanelModel;
        get detailPanelId(): string;
        get isDetailPanelShowing(): boolean;
        showDetailPanel(): void;
        hideDetailPanel(destroyPanel?: boolean): void;
        getAllValues(): any;
        getFilteredValues(): any;
        getFilteredProperties(): any;
        runCondition(values: HashTable<any>, properties: HashTable<any>): void;
        clearValue(): void;
        onAnyValueChanged(name: string): void;
        getDataValueCore(valuesHash: any, key: string): any;
        getValue(name: string): any;
        setValue(name: string, newColumnValue: any): void;
        getVariable(name: string): any;
        setVariable(name: string, newValue: any): void;
        getComment(name: string): string;
        setComment(name: string, newValue: string, locNotification: any): void;
        get isEmpty(): boolean;
        getQuestionByColumn(column: MatrixDropdownColumn): Question;
        getCellByColumn(column: MatrixDropdownColumn): MatrixDropdownCell;
        getQuestionByColumnName(columnName: string): Question;
        get questions(): Array<Question>;
        getQuestionByName(name: string): Question;
        getQuestionsByName(name: string): Array<Question>;
        protected getSharedQuestionByName(columnName: string): Question;
        clearIncorrectValues(val: any): void;
        getLocale(): string;
        getMarkdownHtml(text: string, name: string): string;
        getRenderer(name: string): string;
        getRendererContext(locStr: LocalizableString): any;
        getProcessedText(text: string): string;
        locStrsChanged(): void;
        updateCellQuestionOnColumnChanged(column: MatrixDropdownColumn, name: string, newValue: any): void;
        updateCellQuestionOnColumnItemValueChanged(column: MatrixDropdownColumn, propertyName: string, obj: ItemValue, name: string, newValue: any, oldValue: any): void;
        onQuestionReadOnlyChanged(parentIsReadOnly: boolean): void;
        hasErrors(fireCallback: boolean, rec: any, raiseOnCompletedAsyncValidators: () => void): boolean;
        protected updateCellOnColumnChanged(cell: MatrixDropdownCell, name: string, newValue: any): void;
        updateCellOnColumnItemValueChanged(cell: MatrixDropdownCell, propertyName: string, obj: ItemValue, name: string, newValue: any, oldValue: any): void;
        protected buildCells(value: any): void;
        protected isTwoValueEquals(val1: any, val2: any): boolean;
        protected createCell(column: MatrixDropdownColumn): MatrixDropdownCell;
        getSurveyData(): ISurveyData;
        getSurvey(): ISurvey;
        getTextProcessor(): ITextProcessor;
        get rowIndex(): number;
        get editingObj(): Base;
        dispose(): void;
}
export declare class MatrixDropdownTotalRowModel extends MatrixDropdownRowModelBase {
        constructor(data: IMatrixDropdownData);
        protected createCell(column: MatrixDropdownColumn): MatrixDropdownCell;
        setValue(name: string, newValue: any): void;
        runCondition(values: HashTable<any>, properties: HashTable<any>): void;
        protected updateCellOnColumnChanged(cell: MatrixDropdownCell, name: string, newValue: any): void;
}
/**
    * A base class for matrix dropdown and matrix dynamic questions.
    */
export declare class QuestionMatrixDropdownModelBase extends QuestionMatrixBaseModel<MatrixDropdownRowModelBase, MatrixDropdownColumn> implements IMatrixDropdownData {
        static get defaultCellType(): string;
        static set defaultCellType(val: string);
        static addDefaultColumns(matrix: QuestionMatrixDropdownModelBase): void;
        protected isRowChanging: boolean;
        columnsChangedCallback: () => void;
        onRenderedTableResetCallback: () => void;
        onRenderedTableCreatedCallback: (table: QuestionMatrixDropdownRenderedTable) => void;
        onCellCreatedCallback: (options: any) => void;
        onCellValueChangedCallback: (options: any) => void;
        onHasDetailPanelCallback: (row: MatrixDropdownRowModelBase) => boolean;
        onCreateDetailPanelCallback: (row: MatrixDropdownRowModelBase, panel: PanelModel) => void;
        onCreateDetailPanelRenderedRowCallback: (renderedRow: QuestionMatrixDropdownRenderedRow) => void;
        protected createColumnValues(): any[];
        constructor(name: string);
        getType(): string;
        dispose(): void;
        get hasSingleInput(): boolean;
        get isRowsDynamic(): boolean;
        protected get isUpdateLocked(): boolean;
        beginUpdate(): void;
        endUpdate(): void;
        protected updateColumnsAndRows(): void;
        itemValuePropertyChanged(item: ItemValue, name: string, oldValue: any, newValue: any): void;
        /**
            * Set columnLayout to 'vertical' to place columns vertically and rows horizontally. It makes sense when we have many columns and few rows.
            * @see columns
            * @see rowCount
            */
        get columnLayout(): string;
        set columnLayout(val: string);
        get columnsLocation(): string;
        set columnsLocation(val: string);
        /**
            * Returns true if columns are located horizontally
            * @see columnLayout
            */
        get isColumnLayoutHorizontal(): boolean;
        /**
            * Set the value to "underRow" to show the detailPanel under the row.
            */
        get detailPanelMode(): string;
        set detailPanelMode(val: string);
        /**
            * The detail template Panel. This panel is used as a template on creating detail panel for a row.
            * @see  detailElements
            * @see detailPanelMode
            */
        get detailPanel(): PanelModel;
        getPanel(): IPanel;
        /**
            * The template Panel elements, questions and panels.
            * @see  detailPanel
            * @see detailPanelMode
            */
        get detailElements(): Array<IElement>;
        protected createNewDetailPanel(): PanelModel;
        get hasRowText(): boolean;
        getFooterText(): LocalizableString;
        get canAddRow(): boolean;
        get canRemoveRows(): boolean;
        canRemoveRow(row: MatrixDropdownRowModelBase): boolean;
        protected onRowsChanged(): void;
        protected onStartRowAddingRemoving(): void;
        protected onEndRowAdding(): void;
        protected onEndRowRemoving(row: MatrixDropdownRowModelBase): void;
        protected clearRowsAndResetRenderedTable(): void;
        protected resetRenderedTable(): void;
        protected clearGeneratedRows(): void;
        get renderedTable(): QuestionMatrixDropdownRenderedTable;
        protected createRenderedTable(): QuestionMatrixDropdownRenderedTable;
        protected onMatrixRowCreated(row: MatrixDropdownRowModelBase): void;
        /**
            * Use this property to change the default cell type.
            */
        get cellType(): string;
        set cellType(val: string);
        /**
            * The default column count for radiogroup and checkbox  cell types.
            */
        get columnColCount(): number;
        set columnColCount(value: number);
        /**
            * Use this property to set the minimum column width.
            */
        get columnMinWidth(): string;
        set columnMinWidth(val: string);
        /**
            * Set this property to true to show the horizontal scroll.
            */
        get horizontalScroll(): boolean;
        set horizontalScroll(val: boolean);
        /**
            * The Matrix toolbar and inner panel toolbars get adaptive if the property is set to true.
            */
        get allowAdaptiveActions(): boolean;
        set allowAdaptiveActions(val: boolean);
        getRequiredText(): string;
        onColumnPropertyChanged(column: MatrixDropdownColumn, name: string, newValue: any): void;
        onColumnItemValuePropertyChanged(column: MatrixDropdownColumn, propertyName: string, obj: ItemValue, name: string, newValue: any, oldValue: any): void;
        onShowInMultipleColumnsChanged(column: MatrixDropdownColumn): void;
        onColumnCellTypeChanged(column: MatrixDropdownColumn): void;
        getRowTitleWidth(): string;
        get hasFooter(): boolean;
        getAddRowLocation(): string;
        getShowColumnsIfEmpty(): boolean;
        protected updateShowTableAndAddRow(): void;
        protected updateHasFooter(): void;
        get hasTotal(): boolean;
        getCellType(): string;
        getCustomCellType(column: MatrixDropdownColumn, row: MatrixDropdownRowModelBase, cellType: string): string;
        getConditionJson(operator?: string, path?: string): any;
        clearIncorrectValues(): void;
        clearErrors(): void;
        runCondition(values: HashTable<any>, properties: HashTable<any>): void;
        protected shouldRunColumnExpression(): boolean;
        protected runCellsCondition(values: HashTable<any>, properties: HashTable<any>): void;
        protected runTotalsCondition(values: HashTable<any>, properties: HashTable<any>): void;
        locStrsChanged(): void;
        /**
            * Returns the column by it's name. Returns null if a column with this name doesn't exist.
            * @param column
            */
        getColumnByName(columnName: string): MatrixDropdownColumn;
        getColumnName(columnName: string): MatrixDropdownColumn;
        /**
            * Returns the column width.
            * @param column
            */
        getColumnWidth(column: MatrixDropdownColumn): string;
        /**
            * The default choices for dropdown, checkbox and radiogroup cell types.
            */
        get choices(): Array<any>;
        set choices(val: Array<any>);
        /**
            * The default options caption for dropdown cell type.
            */
        get optionsCaption(): string;
        set optionsCaption(val: string);
        get locOptionsCaption(): LocalizableString;
        /**
            * The duplication value error text. Set it to show the text different from the default.
            * @see MatrixDropdownColumn.isUnique
            */
        get keyDuplicationError(): string;
        set keyDuplicationError(val: string);
        get locKeyDuplicationError(): LocalizableString;
        get storeOthersAsComment(): boolean;
        addColumn(name: string, title?: string): MatrixDropdownColumn;
        protected getVisibleRows(): Array<MatrixDropdownRowModelBase>;
        get totalValue(): any;
        protected getVisibleTotalRow(): MatrixDropdownRowModelBase;
        get visibleTotalRow(): MatrixDropdownRowModelBase;
        onSurveyLoad(): void;
        /**
            * Returns the row value. If the row value is empty, the object is empty: {}.
            * @param rowIndex row index from 0 to visible row count - 1.
            */
        getRowValue(rowIndex: number): any;
        checkIfValueInRowDuplicated(checkedRow: MatrixDropdownRowModelBase, cellQuestion: Question): boolean;
        /**
            * Set the row value.
            * @param rowIndex row index from 0 to visible row count - 1.
            * @param rowValue an object {"column name": columnValue,... }
            */
        setRowValue(rowIndex: number, rowValue: any): any;
        protected generateRows(): Array<MatrixDropdownRowModelBase>;
        protected generateTotalRow(): MatrixDropdownRowModelBase;
        protected createNewValue(nullOnEmpty?: boolean): any;
        protected getRowValueCore(row: MatrixDropdownRowModelBase, questionValue: any, create?: boolean): any;
        protected getRowObj(row: MatrixDropdownRowModelBase): any;
        protected getRowDisplayValue(keysAsText: boolean, row: MatrixDropdownRowModelBase, rowValue: any): any;
        getPlainData(options?: {
                includeEmpty?: boolean;
                calculations?: Array<{
                        propertyName: string;
                }>;
        }): any;
        getProgressInfo(): IProgressInfo;
        protected onBeforeValueChanged(val: any): void;
        protected setQuestionValue(newValue: any): void;
        supportGoNextPageAutomatic(): boolean;
        protected getContainsErrors(): boolean;
        protected getIsAnswered(): boolean;
        hasErrors(fireCallback?: boolean, rec?: any): boolean;
        protected getIsRunningValidators(): boolean;
        getAllErrors(): Array<SurveyError>;
        protected getUniqueColumns(): Array<MatrixDropdownColumn>;
        protected getFirstInputElementId(): string;
        protected getFirstErrorInputElementId(): string;
        protected getFirstCellQuestion(onError: boolean): Question;
        protected onReadOnlyChanged(): void;
        createQuestion(row: MatrixDropdownRowModelBase, column: MatrixDropdownColumn): Question;
        protected createQuestionCore(row: MatrixDropdownRowModelBase, column: MatrixDropdownColumn): Question;
        protected deleteRowValue(newValue: any, row: MatrixDropdownRowModelBase): any;
        onAnyValueChanged(name: string): void;
        protected isObject(value: any): boolean;
        protected onCellValueChanged(row: MatrixDropdownRowModelBase, columnName: string, rowValue: any): void;
        validateCell(row: MatrixDropdownRowModelBase, columnName: string, rowValue: any): SurveyError;
        get isValidateOnValueChanging(): boolean;
        onRowChanging(row: MatrixDropdownRowModelBase, columnName: string, rowValue: any): any;
        onRowChanged(row: MatrixDropdownRowModelBase, columnName: string, newRowValue: any, isDeletingValue: boolean): void;
        getRowIndex(row: MatrixDropdownRowModelBase): number;
        getElementsInDesign(includeHidden?: boolean): Array<IElement>;
        hasDetailPanel(row: MatrixDropdownRowModelBase): boolean;
        getIsDetailPanelShowing(row: MatrixDropdownRowModelBase): boolean;
        setIsDetailPanelShowing(row: MatrixDropdownRowModelBase, val: boolean): void;
        getDetailPanelButtonCss(row: MatrixDropdownRowModelBase): string;
        getDetailPanelIconCss(row: MatrixDropdownRowModelBase): string;
        createRowDetailPanel(row: MatrixDropdownRowModelBase): PanelModel;
        getSharedQuestionByName(columnName: string, row: MatrixDropdownRowModelBase): Question;
        onTotalValueChanged(): any;
        getParentTextProcessor(): ITextProcessor;
        getQuestionFromArray(name: string, index: number): IQuestion;
        getCellTemplateData(cell: QuestionMatrixDropdownRenderedCell): any;
        getCellWrapperComponentName(cell: MatrixDropdownCell): string;
        getCellWrapperComponentData(cell: MatrixDropdownCell): any;
        getColumnHeaderWrapperComponentName(cell: MatrixDropdownCell): string;
        getColumnHeaderWrapperComponentData(cell: MatrixDropdownCell): any;
        getRowHeaderWrapperComponentName(cell: MatrixDropdownCell): string;
        getRowHeaderWrapperComponentData(cell: MatrixDropdownCell): any;
}

export declare type VerticalPosition = "top" | "bottom" | "middle";
export declare type HorizontalPosition = "left" | "right" | "center";
export interface IPosition {
    left?: number | string;
    top?: number | string;
}
export interface INumberPosition extends IPosition {
    left?: number;
    top?: number;
}
export interface ISize {
    width: number;
    height: number;
}
export declare class PopupUtils {
    static calculatePosition(targetRect: ClientRect, height: number, width: number, verticalPosition: VerticalPosition, horizontalPosition: HorizontalPosition, showPointer: boolean): INumberPosition;
    static updateVerticalDimensions(top: number, height: number, windowHeight: number): {
        height: number;
        top: number;
    };
    static updateHorizontalDimensions(left: number, width: number, windowWidth: number, horizontalPosition: HorizontalPosition): {
        width: number;
        left: number;
    };
    static updateVerticalPosition(targetRect: ClientRect, height: number, verticalPosition: VerticalPosition, showPointer: boolean, windowHeight: number): VerticalPosition;
    static calculatePopupDirection(verticalPosition: VerticalPosition, horizontalPosition: HorizontalPosition): string;
    static calculatePointerTarget(targetRect: ClientRect, top: number, left: number, verticalPosition: VerticalPosition, horizontalPosition: HorizontalPosition): INumberPosition;
}

/**
    * Base class of SurveyJS Elements and Survey.
    */
export declare abstract class SurveyElementCore extends Base implements ILocalizableOwner {
        constructor();
        protected createLocTitleProperty(): LocalizableString;
        /**
            * Question, Panel, Page and Survey title. If page and panel is empty then they are not rendered.
            * Question renders question name if the title is empty. Use survey questionTitleTemplate property to change the title question rendering.
            * @see SurveyModel.questionTitleTemplate
         */
        get title(): string;
        set title(val: string);
        get locTitle(): LocalizableString;
        protected getDefaultTitleValue(): string;
        /**
            * Question, Panel and Page description. It renders under element title by using smaller font. Unlike the question title, description can be empty.
            * Please note, this property is hidden for questions without input, for example html question.
            * @see title
         */
        get description(): string;
        set description(val: string);
        get locDescription(): LocalizableString;
        get titleTagName(): string;
        protected getDefaultTitleTagName(): string;
        get hasTitle(): boolean;
        get hasTitleActions(): boolean;
        get hasTitleEvents(): boolean;
        getTitleToolbar(): AdaptiveActionContainer;
        getTitleOwner(): ITitleOwner;
        get isTitleOwner(): boolean;
        toggleState(): boolean;
        get cssClasses(): any;
        get cssTitle(): string;
        get ariaTitleId(): string;
        get titleTabIndex(): number;
        get titleAriaExpanded(): boolean;
        abstract getLocale(): string;
        abstract getMarkdownHtml(text: string, name: string): string;
        abstract getRenderer(name: string): string;
        abstract getRendererContext(locStr: LocalizableString): any;
        abstract getProcessedText(text: string): string;
}
export declare enum DragTypeOverMeEnum {
        InsideEmptyPanel = 1,
        MultilineRight = 2,
        MultilineLeft = 3
}
/**
    * Base class of SurveyJS Elements.
    */
export declare class SurveyElement extends SurveyElementCore implements ISurveyElement {
        stateChangedCallback: () => void;
        static getProgressInfoByElements(children: Array<SurveyElement>, isRequired: boolean): IProgressInfo;
        dragTypeOverMe: DragTypeOverMeEnum;
        isDragMe: boolean;
        readOnlyChangedCallback: () => void;
        static ScrollElementToTop(elementId: string): boolean;
        static GetFirstNonTextElement(elements: any, removeSpaces?: boolean): any;
        static FocusElement(elementId: string): boolean;
        static CreateDisabledDesignElements: boolean;
        disableDesignActions: boolean;
        constructor(name: string);
        protected onPropertyValueChanged(name: string, oldValue: any, newValue: any): void;
        protected getSkeletonComponentNameCore(): string;
        get skeletonComponentName(): string;
        /**
            * Set this property to "collapsed" to render only Panel title and expanded button and to "expanded" to render the collapsed button in the Panel caption
            */
        get state(): string;
        set state(val: string);
        /**
            * Returns true if the Element is in the collapsed state
            * @see state
            * @see collapse
            * @see isExpanded
            */
        get isCollapsed(): boolean;
        /**
            * Returns true if the Element is in the expanded state
            * @see state
            * @see expand
            * @see isCollapsed
            */
        get isExpanded(): boolean;
        /**
            * Collapse the Element
            * @see state
            */
        collapse(): void;
        /**
            * Expand the Element
            * @see state
            */
        expand(): void;
        /**
            * Toggle element's state
            * @see state
            */
        toggleState(): boolean;
        get hasStateButton(): boolean;
        get shortcutText(): string;
        getTitleToolbar(): AdaptiveActionContainer;
        get titleActions(): Array<any>;
        getTitleActions(): Array<any>;
        get hasTitleActions(): boolean;
        get hasTitleEvents(): boolean;
        getTitleComponentName(): string;
        get titleTabIndex(): number;
        get titleAriaExpanded(): boolean;
        setSurveyImpl(value: ISurveyImpl, isLight?: boolean): void;
        protected get surveyImpl(): ISurveyImpl;
        get data(): ISurveyData;
        /**
            * Returns the survey object.
            */
        get survey(): ISurvey;
        getSurvey(live?: boolean): ISurvey;
        protected setSurveyCore(value: ISurvey): void;
        /**
            * Returns true if the question in design mode right now.
            */
        get isDesignMode(): boolean;
        isContentElement: boolean;
        isEditableTemplateElement: boolean;
        isInteractiveDesignElement: boolean;
        protected get isInternal(): boolean;
        get areInvisibleElementsShowing(): boolean;
        get isVisible(): boolean;
        get isReadOnly(): boolean;
        /**
            * Set it to true to make an element question/panel/page readonly.
            * Please note, this property is hidden for question without input, for example html question.
            * @see enableIf
            * @see isReadOnly
            */
        get readOnly(): boolean;
        set readOnly(val: boolean);
        protected onReadOnlyChanged(): void;
        cssClassesValue: any;
        /**
            * Returns all css classes that used for rendering the question, panel or page.
            * You can use survey.onUpdateQuestionCssClasses event to override css classes for a question, survey.onUpdatePanelCssClasses event for a panel and survey.onUpdatePageCssClasses for a page.
            * @see SurveyModel.updateQuestionCssClasses
            * @see SurveyModel.updatePanelCssClasses
            * @see SurveyModel.updatePageCssClasses
            */
        get cssClasses(): any;
        protected calcCssClasses(css: any): any;
        protected updateElementCssCore(cssClasses: any): void;
        get cssError(): string;
        updateElementCss(reNew?: boolean): void;
        protected getIsLoadingFromJson(): boolean;
        /**
            * This is the identifier of a survey element - question or panel.
            * @see valueName
            */
        get name(): string;
        set name(val: string);
        protected getValidName(name: string): string;
        protected onNameChanged(oldValue: string): void;
        protected updateBindingValue(valueName: string, value: any): void;
        /**
            * The list of errors. It is created by callig hasErrors functions
            * @see hasErrors
            */
        get errors(): Array<SurveyError>;
        set errors(val: Array<SurveyError>);
        hasVisibleErrors: boolean;
        /**
            * Returns true if a question or a container (panel/page) or their chidren have an error.
            * The value can be out of date. hasErrors function should be called to get the correct value.
            */
        get containsErrors(): boolean;
        updateContainsErrors(): void;
        protected getContainsErrors(): boolean;
        getElementsInDesign(includeHidden?: boolean): Array<IElement>;
        get selectedElementInDesign(): SurveyElement;
        set selectedElementInDesign(val: SurveyElement);
        updateCustomWidgets(): void;
        onSurveyLoad(): void;
        onFirstRendering(): void;
        endLoadingFromJson(): void;
        setVisibleIndex(index: number): number;
        /**
            * Returns true if it is a page.
            */
        get isPage(): boolean;
        /**
            * Returns true if it is a panel.
            */
        get isPanel(): boolean;
        /**
            * Returns true if it is a question.
            */
        get isQuestion(): boolean;
        delete(): void;
        locOwner: ILocalizableOwner;
        /**
            * Returns the current survey locale
            * @see SurveyModel.locale
            */
        getLocale(): string;
        getMarkdownHtml(text: string, name: string): string;
        getRenderer(name: string): string;
        getRendererContext(locStr: LocalizableString): any;
        getProcessedText(text: string): string;
        protected getUseDisplayValuesInTitle(): boolean;
        protected removeSelfFromList(list: Array<any>): void;
        protected get textProcessor(): ITextProcessor;
        protected getProcessedHtml(html: string): string;
        protected onSetData(): void;
        get parent(): IPanel;
        set parent(val: IPanel);
        protected getPage(parent: IPanel): IPage;
        protected moveToBase(parent: IPanel, container: IPanel, insertBefore?: any): boolean;
        protected setPage(parent: IPanel, newPage: IPage): void;
        protected getSearchableLocKeys(keys: Array<string>): void;
        protected get isDefaultV2Theme(): boolean;
        get isErrorsModeTooltip(): boolean;
        get hasParent(): boolean;
        protected get hasFrameV2(): boolean;
}

export declare class ValidatorResult {
        value: any;
        error: SurveyError;
        constructor(value: any, error?: SurveyError);
}
/**
    * Base SurveyJS validator class.
    */
export declare class SurveyValidator extends Base {
        errorOwner: ISurveyErrorOwner;
        onAsyncCompleted: (result: ValidatorResult) => void;
        constructor();
        getSurvey(live?: boolean): ISurvey;
        get text(): string;
        set text(value: string);
        get isValidateAllValues(): boolean;
        get locText(): LocalizableString;
        protected getErrorText(name: string): string;
        protected getDefaultErrorText(name: string): string;
        validate(value: any, name?: string, values?: any, properties?: any): ValidatorResult;
        get isRunning(): boolean;
        get isAsync(): boolean;
        getLocale(): string;
        getMarkdownHtml(text: string, name: string): string;
        getRenderer(name: string): string;
        getRendererContext(locStr: LocalizableString): any;
        getProcessedText(text: string): string;
        protected createCustomError(name: string): SurveyError;
        toString(): string;
}
export interface IValidatorOwner {
        getValidators(): Array<SurveyValidator>;
        validatedValue: any;
        getValidatorTitle(): string;
        getDataFilteredValues(): any;
        getDataFilteredProperties(): any;
}
export declare class ValidatorRunner {
        onAsyncCompleted: (errors: Array<SurveyError>) => void;
        run(owner: IValidatorOwner): Array<SurveyError>;
}
/**
    * Validate numeric values.
    */
export declare class NumericValidator extends SurveyValidator {
        constructor(minValue?: number, maxValue?: number);
        getType(): string;
        validate(value: any, name?: string, values?: any, properties?: any): ValidatorResult;
        protected getDefaultErrorText(name: string): any;
        /**
            * The minValue property.
            */
        get minValue(): number;
        set minValue(val: number);
        /**
            * The maxValue property.
            */
        get maxValue(): number;
        set maxValue(val: number);
}
/**
    * Validate text values.
    */
export declare class TextValidator extends SurveyValidator {
        constructor();
        getType(): string;
        validate(value: any, name?: string, values?: any, properties?: any): ValidatorResult;
        protected getDefaultErrorText(name: string): any;
        /**
            * The minLength property.
            */
        get minLength(): number;
        set minLength(val: number);
        /**
            * The maxLength property.
            */
        get maxLength(): number;
        set maxLength(val: number);
        /**
            * The allowDigits property.
            */
        get allowDigits(): boolean;
        set allowDigits(val: boolean);
}
export declare class AnswerCountValidator extends SurveyValidator {
        constructor(minCount?: number, maxCount?: number);
        getType(): string;
        validate(value: any, name?: string, values?: any, properties?: any): ValidatorResult;
        protected getDefaultErrorText(name: string): string;
        /**
            * The minCount property.
            */
        get minCount(): number;
        set minCount(val: number);
        /**
            * The maxCount property.
            */
        get maxCount(): number;
        set maxCount(val: number);
}
/**
    * Use it to validate the text by regular expressions.
    */
export declare class RegexValidator extends SurveyValidator {
        constructor(regex?: string);
        getType(): string;
        validate(value: any, name?: string, values?: any, properties?: any): ValidatorResult;
        /**
            * The regex property.
            */
        get regex(): string;
        set regex(val: string);
}
/**
    * Validate e-mail address in the text input
    */
export declare class EmailValidator extends SurveyValidator {
        constructor();
        getType(): string;
        validate(value: any, name?: string, values?: any, properties?: any): ValidatorResult;
        protected getDefaultErrorText(name: string): any;
}
/**
    * Show error if expression returns false
    */
export declare class ExpressionValidator extends SurveyValidator {
        constructor(expression?: string);
        getType(): string;
        get isValidateAllValues(): boolean;
        get isAsync(): boolean;
        get isRunning(): boolean;
        validate(value: any, name?: string, values?: any, properties?: any): ValidatorResult;
        protected generateError(res: boolean, value: any, name: string): ValidatorResult;
        protected getDefaultErrorText(name: string): any;
        protected ensureConditionRunner(): boolean;
        /**
            * The expression property.
            */
        get expression(): string;
        set expression(val: string);
}

export declare class TextPreProcessorItem {
    start: number;
    end: number;
}
export declare class TextPreProcessorValue {
    name: string;
    returnDisplayValue: boolean;
    constructor(name: string, returnDisplayValue: boolean);
    value: any;
    isExists: boolean;
    canProcess: boolean;
}
export declare class TextPreProcessor {
    onProcess: (textValue: TextPreProcessorValue) => void;
    process(text: string, returnDisplayValue?: boolean, doEncoding?: boolean): string;
    processValue(name: string, returnDisplayValue: boolean): TextPreProcessorValue;
    get hasAllValuesOnLastRun(): boolean;
}
export declare class QuestionTextProcessor implements ITextProcessor {
    protected variableName: string;
    constructor(variableName: string);
    processValue(name: string, returnDisplayValue: boolean): TextPreProcessorValue;
    protected get survey(): ISurvey;
    protected get panel(): PanelModel;
    protected getValues(): any;
    protected getQuestionByName(name: string): Question;
    protected getParentTextProcessor(): ITextProcessor;
    protected onCustomProcessText(textValue: TextPreProcessorValue): boolean;
    processText(text: string, returnDisplayValue: boolean): string;
    processTextEx(text: string, returnDisplayValue: boolean): any;
}

export declare class QuestionCustomWidget {
        name: string;
        widgetJson: any;
        htmlTemplate: string;
        isFirstRender: boolean;
        constructor(name: string, widgetJson: any);
        afterRender(question: IQuestion, el: any): void;
        willUnmount(question: IQuestion, el: any): void;
        getDisplayValue(question: IQuestion, value?: any): string;
        isFit(question: IQuestion): boolean;
        get canShowInToolbox(): boolean;
        get showInToolbox(): boolean;
        set showInToolbox(val: boolean);
        init(): void;
        activatedByChanged(activatedBy: string): void;
        get isDefaultRender(): boolean;
        get pdfQuestionType(): string;
        get pdfRender(): any;
}
export declare class CustomWidgetCollection {
        static Instance: CustomWidgetCollection;
        onCustomWidgetAdded: Event<(customWidget: QuestionCustomWidget) => any, any>;
        get widgets(): Array<QuestionCustomWidget>;
        add(widgetJson: any, activatedBy?: string): void;
        addCustomWidget(widgetJson: any, activatedBy?: string): QuestionCustomWidget;
        /**
            * Returns the way the custom wiget is activated. It can be activated by a property ("property"), question type ("type") or by new/custom question type ("customtype").
            * @param widgetName the custom widget name
            * @see setActivatedBy
            */
        getActivatedBy(widgetName: string): string;
        /**
            * Sets the way the custom wiget is activated. The activation types are: property ("property"), question type ("type") or new/custom question type ("customtype"). A custom wiget may support all or only some of this activation types.
            * @param widgetName
            * @param activatedBy there are three possible variants: "property", "type" and "customtype"
            */
        setActivatedBy(widgetName: string, activatedBy: string): void;
        clear(): void;
        getCustomWidgetByName(name: string): QuestionCustomWidget;
        getCustomWidget(question: IQuestion): QuestionCustomWidget;
}

/**
    * A Model for a matrix base question.
    */
export declare class QuestionMatrixBaseModel<TRow, TColumn> extends Question {
        protected filteredColumns: Array<TColumn>;
        protected filteredRows: Array<ItemValue>;
        protected generatedVisibleRows: Array<TRow>;
        protected generatedTotalRow: TRow;
        visibleRowsChangedCallback: () => void;
        protected createColumnValues(): any;
        constructor(name: string);
        getType(): string;
        get isCompositeQuestion(): boolean;
        /**
            * Set this property to false, to hide table header. The default value is true.
            */
        get showHeader(): boolean;
        set showHeader(val: boolean);
        /**
            * The list of columns. A column has a value and an optional text
            */
        get columns(): Array<any>;
        set columns(newValue: Array<any>);
        get visibleColumns(): Array<any>;
        /**
            * The list of rows. A row has a value and an optional text
            */
        get rows(): Array<any>;
        set rows(newValue: Array<any>);
        protected processRowsOnSet(newRows: Array<any>): any[];
        protected getVisibleRows(): Array<TRow>;
        /**
            * Returns the list of visible rows as model objects.
            * @see rowsVisibleIf
            */
        get visibleRows(): Array<TRow>;
        /**
            * An expression that returns true or false. It runs against each row item and if for this item it returns true, then the item is visible otherwise the item becomes invisible. Please use {item} to get the current item value in the expression.
            * @see visibleIf
            */
        get rowsVisibleIf(): string;
        set rowsVisibleIf(val: string);
        /**
            * An expression that returns true or false. It runs against each column item and if for this item it returns true, then the item is visible otherwise the item becomes invisible. Please use {item} to get the current item value in the expression.
            * @see rowsVisibleIf
            */
        get columnsVisibleIf(): string;
        set columnsVisibleIf(val: string);
        runCondition(values: HashTable<any>, properties: HashTable<any>): void;
        protected filterItems(): boolean;
        protected onColumnsChanged(): void;
        protected onRowsChanged(): void;
        protected shouldRunColumnExpression(): boolean;
        protected hasRowsAsItems(): boolean;
        protected runItemsCondition(values: HashTable<any>, properties: HashTable<any>): boolean;
        protected clearGeneratedRows(): void;
        clearIncorrectValues(): void;
        protected clearInvisibleValuesInRows(): void;
        needResponsiveWidth(): boolean;
}

export declare class DragDropInfo {
        source: IElement;
        target: IElement;
        nestedPanelDepth: number;
        constructor(source: IElement, target: IElement, nestedPanelDepth?: number);
        destination: ISurveyElement;
        isBottom: boolean;
        isEdge: boolean;
}
export declare class QuestionRowModel extends Base {
        panel: PanelModelBase;
        protected _scrollableParent: any;
        protected _updateVisibility: any;
        startLazyRendering(rowContainerDiv: HTMLElement, findScrollableContainer?: typeof findScrollableParent): void;
        ensureVisibility(): void;
        stopLazyRendering(): void;
        constructor(panel: PanelModelBase);
        setIsLazyRendering(val: boolean): void;
        isLazyRendering(): boolean;
        get id(): string;
        get elements(): Array<IElement>;
        get visibleElements(): Array<IElement>;
        get visible(): boolean;
        set visible(val: boolean);
        get isNeedRender(): boolean;
        set isNeedRender(val: boolean);
        updateVisible(): void;
        addElement(q: IElement): void;
        get index(): number;
        setElementMaxMinWidth(el: IElement): void;
        dispose(): void;
        getRowCss(): string;
}
/**
    * A base class for a Panel and Page objects.
    */
export declare class PanelModelBase extends SurveyElement implements IPanel, IConditionRunner, ISurveyErrorOwner, ITitleOwner {
        addElementCallback: (element: IElement) => void;
        removeElementCallback: (element: IElement) => void;
        onGetQuestionTitleLocation: () => string;
        constructor(name?: string);
        getType(): string;
        setSurveyImpl(value: ISurveyImpl, isLight?: boolean): void;
        endLoadingFromJson(): void;
        get hasTitle(): boolean;
        get hasDescription(): boolean;
        protected canShowTitle(): boolean;
        get _showDescription(): boolean;
        localeChanged(): void;
        locStrsChanged(): void;
        /**
            * Returns the char/string for a required panel.
            * @see SurveyModel.requiredText
            */
        get requiredText(): string;
        protected get titlePattern(): string;
        get isRequireTextOnStart(): boolean;
        get isRequireTextBeforeTitle(): boolean;
        get isRequireTextAfterTitle(): boolean;
        /**
            * The custom text that will be shown on required error. Use this property, if you do not want to show the default text.
            */
        get requiredErrorText(): string;
        set requiredErrorText(val: string);
        get locRequiredErrorText(): LocalizableString;
        /**
            * Use this property to randomize questions. Set it to 'random' to randomize questions, 'initial' to keep them in the same order or 'default' to use the Survey questionsOrder property
            * @see SurveyModel.questionsOrder
            * @see areQuestionsRandomized
            */
        get questionsOrder(): string;
        set questionsOrder(val: string);
        protected isRandomizing: boolean;
        randomizeElements(isRandom: boolean): void;
        /**
            * A parent element. It is always null for the Page object and always not null for the Panel object. Panel object may contain Questions and other Panels.
            */
        get parent(): PanelModelBase;
        set parent(val: PanelModelBase);
        get depth(): number;
        /**
            * An expression that returns true or false. If it returns true the Panel becomes visible and if it returns false the Panel becomes invisible. The library runs the expression on survey start and on changing a question value. If the property is empty then visible property is used.
            * @see visible
            */
        get visibleIf(): string;
        set visibleIf(val: string);
        protected calcCssClasses(css: any): any;
        /**
            * A unique element identificator. It is generated automatically.
            */
        get id(): string;
        set id(val: string);
        /**
            * Returns true if the current object is Panel. Returns false if the current object is Page (a root Panel).
            */
        get isPanel(): boolean;
        getPanel(): IPanel;
        getLayoutType(): string;
        isLayoutTypeSupported(layoutType: string): boolean;
        /**
            * Returns the list of all questions located in the Panel/Page, including in the nested Panels.
            * @see Question
            * @see elements
            */
        get questions(): Array<Question>;
        protected getValidName(name: string): string;
        /**
            * Returns the question by its name
            * @param name the question name
            */
        getQuestionByName(name: string): Question;
        /**
            * Returns the element by its name. It works recursively.
            * @param name the element name
            */
        getElementByName(name: string): IElement;
        getQuestionByValueName(valueName: string): Question;
        /**
            * Returns question values on the current page
            */
        getValue(): any;
        /**
            * Return questions values as a JSON object with display text. For example, for dropdown, it would return the item text instead of item value.
            * @param keysAsText Set this value to true, to return key (in matrices questions) as display text as well.
            */
        getDisplayValue(keysAsText: boolean): any;
        /**
            * Returns question comments on the current page
            */
        getComments(): any;
        /**
            * Call this function to remove all question values from the current page/panel, that end-user will not be able to enter.
            * For example the value that doesn't exists in a radigroup/dropdown/checkbox choices or matrix rows/columns.
            * Please note, this function doesn't clear values for invisible questions or values that doesn't associated with questions.
            * @see Question.clearIncorrectValues
            */
        clearIncorrectValues(): void;
        /**
            * Call this function to clear all errors in the panel / page and all its child elements (panels and questions)
            */
        clearErrors(): void;
        /**
            * Returns the list of the elements in the object, Panel/Page. Elements can be questions or panels. The function doesn't return elements in the nested Panels.
            */
        get elements(): Array<IElement>;
        getElementsInDesign(includeHidden?: boolean): Array<IElement>;
        /**
            * Returns true if the current element belongs to the Panel/Page. It looks in nested Panels as well.
            * @param element
            * @see PanelModel
            */
        containsElement(element: IElement): boolean;
        /**
            * Set this property to true, to require the answer at least in one question in the panel.
            */
        get isRequired(): boolean;
        set isRequired(val: boolean);
        /**
            * An expression that returns true or false. If it returns true the Panel/Page becomes required.
            * The library runs the expression on survey start and on changing a question value. If the property is empty then isRequired property is used.
            * @see isRequired
            */
        get requiredIf(): string;
        set requiredIf(val: string);
        searchText(text: string, founded: Array<IFindElement>): void;
        /**
            * Returns true, if there is an error on this Page or inside the current Panel
            * @param fireCallback set it to true, to show errors in UI
            * @param focusOnFirstError set it to true to focus on the first question that doesn't pass the validation
            */
        hasErrors(fireCallback?: boolean, focusOnFirstError?: boolean, rec?: any): boolean;
        getErrorCustomText(text: string, error: SurveyError): string;
        protected hasErrorsCore(rec: any): void;
        protected getContainsErrors(): boolean;
        updateElementVisibility(): void;
        getFirstQuestionToFocus(withError?: boolean): Question;
        /**
            * Call it to focus the input on the first question
            */
        focusFirstQuestion(): void;
        /**
            * Call it to focus the input of the first question that has an error.
            */
        focusFirstErrorQuestion(): void;
        /**
            * Fill list array with the questions.
            * @param list
            * @param visibleOnly set it to true to get visible questions only
            */
        addQuestionsToList(list: Array<IQuestion>, visibleOnly?: boolean, includingDesignTime?: boolean): void;
        /**
            * Fill list array with the panels.
            * @param list
            */
        addPanelsIntoList(list: Array<IPanel>, visibleOnly?: boolean, includingDesignTime?: boolean): void;
        /**
            * Returns true if the current object is Page and it is the current page.
            */
        get isActive(): boolean;
        updateCustomWidgets(): void;
        /**
            * Set this property different from "default" to set the specific question title location for this panel/page.
            * @see SurveyModel.questionTitleLocation
            */
        get questionTitleLocation(): string;
        set questionTitleLocation(value: string);
        getQuestionTitleLocation(): string;
        protected getStartIndex(): string;
        getQuestionStartIndex(): string;
        getChildrenLayoutType(): string;
        getProgressInfo(): IProgressInfo;
        protected get root(): PanelModelBase;
        protected childVisibilityChanged(): void;
        protected createRowAndSetLazy(index: number): QuestionRowModel;
        protected createRow(): QuestionRowModel;
        onSurveyLoad(): void;
        onFirstRendering(): void;
        updateRows(): void;
        get rows(): Array<QuestionRowModel>;
        ensureRowsVisibility(): void;
        protected onRowsChanged(): void;
        protected onAddElement(element: IElement, index: number): void;
        protected onRemoveElement(element: IElement): void;
        protected canRenderFirstRows(): boolean;
        protected updateRowsRemoveElementFromRow(element: IElement, row: QuestionRowModel): void;
        elementWidthChanged(el: IElement): void;
        /**
            * Returns rendered title text or html.
            */
        get processedTitle(): string;
        protected getRenderedTitle(str: string): string;
        /**
            * Use it to get/set the object visibility.
            * @see visibleIf
            */
        get visible(): boolean;
        set visible(value: boolean);
        protected onVisibleChanged(): void;
        /**
            * Returns true if object is visible or survey is in design mode right now.
            */
        get isVisible(): boolean;
        getIsPageVisible(exceptionQuestion: IQuestion): boolean;
        setVisibleIndex(index: number): number;
        protected beforeSetVisibleIndex(index: number): number;
        protected getPanelStartIndex(index: number): number;
        protected isContinueNumbering(): boolean;
        /**
            * Returns true if readOnly property is true or survey is in display mode or parent panel/page is readOnly.
            * @see SurveyModel.model
            * @see readOnly
            */
        get isReadOnly(): boolean;
        protected onReadOnlyChanged(): void;
        updateElementCss(reNew?: boolean): void;
        /**
            * An expression that returns true or false. If it returns false the Panel/Page becomes read only and an end-user will not able to answer on qustions inside it.
            * The library runs the expression on survey start and on changing a question value. If the property is empty then readOnly property is used.
            * @see readOnly
            * @see isReadOnly
            */
        get enableIf(): string;
        set enableIf(val: string);
        /**
            * Add an element into Panel or Page. Returns true if the element added successfully. Otherwise returns false.
            * @param element
            * @param index element index in the elements array
            */
        addElement(element: IElement, index?: number): boolean;
        insertElementAfter(element: IElement, after: IElement): void;
        insertElementBefore(element: IElement, before: IElement): void;
        protected canAddElement(element: IElement): boolean;
        /**
            * Add a question into Panel or Page. Returns true if the question added successfully. Otherwise returns false.
            * @param question
            * @param index element index in the elements array
            */
        addQuestion(question: Question, index?: number): boolean;
        /**
            * Add a panel into Panel or Page.  Returns true if the panel added successfully. Otherwise returns false.
            * @param panel
            * @param index element index in the elements array
            */
        addPanel(panel: PanelModel, index?: number): boolean;
        /**
            * Creates a new question and adds it at location of index, by default the end of the elements list. Returns null, if the question could not be created or could not be added into page or panel.
            * @param questionType the possible values are: "text", "checkbox", "dropdown", "matrix", "html", "matrixdynamic", "matrixdropdown" and so on.
            * @param name a question name
            * @param index element index in the elements array
            */
        addNewQuestion(questionType: string, name?: string, index?: number): Question;
        /**
            * Creates a new panel and adds it into the end of the elements list. Returns null, if the panel could not be created or could not be added into page or panel.
            * @param name a panel name
            */
        addNewPanel(name?: string): PanelModel;
        /**
            * Returns the index of element parameter in the elements list.
            * @param element question or panel
            */
        indexOf(element: IElement): number;
        protected createNewPanel(name: string): PanelModel;
        /**
            * Remove an element (Panel or Question) from the elements list.
            * @param element
            * @see elements
            */
        removeElement(element: IElement): boolean;
        /**
            * Remove question  from the elements list.
            * @param question
            * @see elements
            * @see removeElement
            */
        removeQuestion(question: Question): void;
        runCondition(values: HashTable<any>, properties: HashTable<any>): void;
        onAnyValueChanged(name: string): void;
        checkBindings(valueName: string, value: any): void;
        protected dragDropAddTarget(dragDropInfo: DragDropInfo): void;
        dragDropFindRow(findElement: ISurveyElement): QuestionRowModel;
        dragDropMoveElement(src: IElement, target: IElement, targetIndex: number): void;
        needResponsiveWidth(): boolean;
        get no(): string;
        dispose(): void;
}
/**
    * A container element, similar to the Page objects. However, unlike the Page, Panel can't be a root.
    * It may contain questions and other panels.
    */
export declare class PanelModel extends PanelModelBase implements IElement {
        constructor(name?: string);
        getType(): string;
        get contentId(): string;
        getSurvey(live?: boolean): ISurvey;
        onSurveyLoad(): void;
        protected onSetData(): void;
        get isPanel(): boolean;
        /**
            * Get/set the page where the panel is located.
            */
        get page(): IPage;
        set page(val: IPage);
        delete(): void;
        /**
            * Move panel to a new container Page/Panel. Add as a last element if insertBefore parameter is not used or inserted into the given index,
            * if insert parameter is number, or before the given element, if the insertBefore parameter is a question or panel
            * @param container Page or Panel to where a question is relocated.
            * @param insertBefore Use it if you want to set the panel to a specific position. You may use a number (use 0 to insert int the beginning) or element, if you want to insert before this element.
            */
        moveTo(container: IPanel, insertBefore?: any): boolean;
        /**
            * Returns the visible index of the panel in the survey. Commonly it is -1 and it doesn't show.
            * You have to set showNumber to true to show index/numbering for the Panel
            * @see showNumber
            */
        get visibleIndex(): number;
        getTitleOwner(): ITitleOwner;
        /**
            * Set showNumber to true to start showing the number for this panel.
            * @see visibleIndex
            */
        get showNumber(): boolean;
        set showNumber(val: boolean);
        /**
            * Gets or sets a value that specifies how the elements numbers inside panel are displayed.
            *
            * The following options are available:
            *
            * - `default` - display questions numbers as defined in parent panel or survey
            * - `onpanel` - display questions numbers, start numbering from beginning of this page
            * - `off` - turn off the numbering for questions titles
            * @see showNumber
            */
        get showQuestionNumbers(): string;
        set showQuestionNumbers(value: string);
        /**
            * Gets or sets the first question index for elements inside the panel. The first question index is '1.' by default and it is taken from survey.questionStartIndex property.
            * You may start it from '100' or from 'A', by setting '100' or 'A' to this property.
            * You can set the start index to "(1)" or "# A)" or "a)" to render question number as (1), # A) and a) accordingly.
            * @see survey.questionStartIndex
            */
        get questionStartIndex(): string;
        set questionStartIndex(val: string);
        getQuestionStartIndex(): string;
        /**
            * The property returns the question number. If question is invisible then it returns empty string.
            * If visibleIndex is 1, then no is 2, or 'B' if survey.questionStartIndex is 'A'.
            * @see SurveyModel.questionStartIndex
            */
        get no(): string;
        protected setNo(visibleIndex: number): void;
        protected beforeSetVisibleIndex(index: number): number;
        protected getPanelStartIndex(index: number): number;
        protected isContinueNumbering(): boolean;
        protected hasErrorsCore(rec: any): void;
        protected getRenderedTitle(str: string): string;
        /**
            * The Panel width.
            */
        get width(): string;
        set width(val: string);
        /**
            * Use it to set the specific minWidth constraint to the panel like css style (%, px, em etc).
            */
        get minWidth(): string;
        set minWidth(val: string);
        /**
            * Use it to set the specific maxWidth constraint to the panel like css style (%, px, em etc).
            */
        get maxWidth(): string;
        set maxWidth(val: string);
        /**
            * The left indent. Set this property to increase the panel left indent.
            */
        get indent(): number;
        set indent(val: number);
        /**
            * The inner indent. Set this property to increase the panel content margin.
            */
        get innerIndent(): number;
        set innerIndent(val: number);
        get renderWidth(): string;
        set renderWidth(val: string);
        /**
            * The Panel renders on the new line if the property is true. If the property is false, the panel tries to render on the same line/row with a previous question/panel.
            */
        get startWithNewLine(): boolean;
        set startWithNewLine(value: boolean);
        /**
            * The right indent of the Panel.
            */
        get rightIndent(): number;
        set rightIndent(val: number);
        /**
            * The Panel toolbar gets adaptive if the property is set to true.
            */
        get allowAdaptiveActions(): boolean;
        set allowAdaptiveActions(val: boolean);
        get paddingLeft(): string;
        set paddingLeft(val: string);
        get innerPaddingLeft(): string;
        set innerPaddingLeft(val: string);
        get paddingRight(): string;
        set paddingRight(val: string);
        clearOnDeletingContainer(): void;
        get footerActions(): Array<IAction>;
        getFooterToolbar(): ActionContainer;
        get hasEditButton(): boolean;
        cancelPreview(): void;
        get cssTitle(): string;
        get cssError(): string;
        protected getCssError(cssClasses: any): string;
        protected onVisibleChanged(): void;
        needResponsiveWidth(): boolean;
        focusIn: () => void;
        getContainerCss(): string;
}

export interface IMatrixColumnOwner extends ILocalizableOwner {
    getRequiredText(): string;
    onColumnPropertyChanged(column: MatrixDropdownColumn, name: string, newValue: any): void;
    onColumnItemValuePropertyChanged(column: MatrixDropdownColumn, propertyName: string, obj: ItemValue, name: string, newValue: any, oldValue: any): void;
    onShowInMultipleColumnsChanged(column: MatrixDropdownColumn): void;
    getCellType(): string;
    getCustomCellType(column: MatrixDropdownColumn, row: MatrixDropdownRowModelBase, cellType: string): string;
    onColumnCellTypeChanged(column: MatrixDropdownColumn): void;
}
export declare var matrixDropdownColumnTypes: {
    dropdown: {
        properties: string[];
        onCellQuestionUpdate: (cellQuestion: any, column: any, question: any, data: any) => void;
    };
    checkbox: {
        properties: string[];
        onCellQuestionUpdate: (cellQuestion: any, column: any, question: any, data: any) => void;
    };
    radiogroup: {
        properties: string[];
        onCellQuestionUpdate: (cellQuestion: any, column: any, question: any, data: any) => void;
    };
    text: {
        properties: string[];
        onCellQuestionUpdate: (cellQuestion: any, column: any, question: any, data: any) => void;
    };
    comment: {
        properties: string[];
        onCellQuestionUpdate: (cellQuestion: any, column: any, question: any, data: any) => void;
    };
    boolean: {
        properties: string[];
        onCellQuestionUpdate: (cellQuestion: any, column: any, question: any, data: any) => void;
    };
    expression: {
        properties: string[];
        onCellQuestionUpdate: (cellQuestion: any, column: any, question: any, data: any) => void;
    };
    rating: {
        properties: string[];
    };
};
export declare class MatrixDropdownColumn extends Base implements ILocalizableOwner, IWrapperObject {
    static getColumnTypes(): Array<string>;
    constructor(name: string, title?: string);
    getOriginalObj(): Base;
    getClassNameProperty(): string;
    getSurvey(live?: boolean): ISurvey;
    endLoadingFromJson(): void;
    getDynamicPropertyName(): string;
    getDynamicType(): string;
    get colOwner(): IMatrixColumnOwner;
    set colOwner(value: IMatrixColumnOwner);
    locStrsChanged(): void;
    addUsedLocales(locales: Array<string>): void;
    get index(): number;
    setIndex(val: number): void;
    getType(): string;
    get cellType(): string;
    set cellType(val: string);
    get templateQuestion(): Question;
    get value(): string;
    get isVisible(): boolean;
    setIsVisible(newVal: boolean): void;
    get hasVisibleCell(): boolean;
    set hasVisibleCell(newVal: boolean);
    get name(): string;
    set name(val: string);
    get title(): string;
    set title(val: string);
    get locTitle(): LocalizableString;
    get fullTitle(): string;
    get isRequired(): boolean;
    set isRequired(val: boolean);
    get requiredText(): string;
    get requiredErrorText(): string;
    set requiredErrorText(val: string);
    get locRequiredErrorText(): LocalizableString;
    get readOnly(): boolean;
    set readOnly(val: boolean);
    get hasOther(): boolean;
    set hasOther(val: boolean);
    get visibleIf(): string;
    set visibleIf(val: string);
    get enableIf(): string;
    set enableIf(val: string);
    get requiredIf(): string;
    set requiredIf(val: string);
    get isUnique(): boolean;
    set isUnique(val: boolean);
    get showInMultipleColumns(): boolean;
    set showInMultipleColumns(val: boolean);
    get isSupportMultipleColumns(): boolean;
    get isShowInMultipleColumns(): boolean;
    get validators(): Array<SurveyValidator>;
    set validators(val: Array<SurveyValidator>);
    get totalType(): string;
    set totalType(val: string);
    get totalExpression(): string;
    set totalExpression(val: string);
    get hasTotal(): boolean;
    get totalFormat(): string;
    set totalFormat(val: string);
    get locTotalFormat(): LocalizableString;
    get renderAs(): string;
    set renderAs(val: string);
    get totalMaximumFractionDigits(): number;
    set totalMaximumFractionDigits(val: number);
    get totalMinimumFractionDigits(): number;
    set totalMinimumFractionDigits(val: number);
    get totalDisplayStyle(): string;
    set totalDisplayStyle(val: string);
    get totalCurrency(): string;
    set totalCurrency(val: string);
    get minWidth(): string;
    set minWidth(val: string);
    get width(): string;
    set width(val: string);
    get colCount(): number;
    set colCount(val: number);
    getLocale(): string;
    getMarkdownHtml(text: string, name: string): string;
    getRenderer(name: string): string;
    getRendererContext(locStr: LocalizableString): any;
    getProcessedText(text: string): string;
    createCellQuestion(row: MatrixDropdownRowModelBase): Question;
    updateCellQuestion(cellQuestion: Question, data: any, onUpdateJson?: (json: any) => any): void;
    defaultCellTypeChanged(): void;
    protected calcCellQuestionType(row: MatrixDropdownRowModelBase): string;
    protected updateTemplateQuestion(): void;
    protected createNewQuestion(cellType: string): Question;
    protected setQuestionProperties(question: Question, onUpdateJson?: (json: any) => any): void;
    protected propertyValueChanged(name: string, oldValue: any, newValue: any): void;
}

export declare class QuestionMatrixDropdownRenderedCell {
    minWidth: string;
    width: string;
    locTitle: LocalizableString;
    cell: MatrixDropdownCell;
    column: MatrixDropdownColumn;
    row: MatrixDropdownRowModelBase;
    question: Question;
    isRemoveRow: boolean;
    choiceIndex: number;
    matrix: QuestionMatrixDropdownModelBase;
    requiredText: string;
    isEmpty: boolean;
    colSpans: number;
    panel: PanelModel;
    isShowHideDetail: boolean;
    isActionsCell: boolean;
    isDragHandlerCell: boolean;
    constructor();
    get hasQuestion(): boolean;
    get hasTitle(): boolean;
    get hasPanel(): boolean;
    get id(): number;
    get showErrorOnTop(): boolean;
    get showErrorOnBottom(): boolean;
    get item(): ItemValue;
    set item(val: ItemValue);
    get isChoice(): boolean;
    get choiceValue(): any;
    get isCheckbox(): boolean;
    get isFirstChoice(): boolean;
    set className(val: string);
    get className(): string;
    get headers(): string;
    calculateFinalClassName(matrixCssClasses: any): string;
}
export declare class QuestionMatrixDropdownRenderedRow extends Base {
    cssClasses: any;
    isDetailRow: boolean;
    ghostPosition: string;
    isAdditionalClasses: boolean;
    row: MatrixDropdownRowModelBase;
    cells: Array<QuestionMatrixDropdownRenderedCell>;
    constructor(cssClasses: any, isDetailRow?: boolean);
    onCreating(): void;
    get id(): number;
    get attributes(): {
        "data-sv-drop-target-matrix-row"?: undefined;
    } | {
        "data-sv-drop-target-matrix-row": string;
    };
    get className(): string;
}
export declare class QuestionMatrixDropdownRenderedTable extends Base {
    matrix: QuestionMatrixDropdownModelBase;
    constructor(matrix: QuestionMatrixDropdownModelBase);
    get showTable(): boolean;
    get showHeader(): boolean;
    get showAddRowOnTop(): boolean;
    get showAddRowOnBottom(): boolean;
    get showFooter(): boolean;
    get hasFooter(): boolean;
    get hasRemoveRows(): boolean;
    isRequireReset(): boolean;
    get headerRow(): QuestionMatrixDropdownRenderedRow;
    get footerRow(): QuestionMatrixDropdownRenderedRow;
    get rows(): Array<QuestionMatrixDropdownRenderedRow>;
    protected build(): void;
    updateShowTableAndAddRow(): void;
    onAddedRow(): void;
    onRemovedRow(row: MatrixDropdownRowModelBase): void;
    onDetailPanelChangeVisibility(row: MatrixDropdownRowModelBase, isShowing: boolean): void;
    protected buildRowsActions(): void;
    protected buildHeader(): void;
    protected buildFooter(): void;
    protected buildRows(): void;
    protected setDefaultRowActions(row: MatrixDropdownRowModelBase, actions: Array<IAction>): void;
}

